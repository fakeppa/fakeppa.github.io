---
icon: pen-to-square
date: 2025-01-03
tags: 
title: C语言
category:
  - 归档
---
**学C**
这是C程序编译后的内存的结构
```bash
高地址 (0x7fffffffffff)
+------------------------------+
|                              |  内核空间 (Kernel Space)
|                              |  (用户程序不可访问)
+------------------------------+  <-- 0x7fffffffffff (1<<47 -1)
|           ...                |
|   环境变量 (Environment vars)  |
|   命令行参数 (Command-line args)|  栈顶 (初始时)
|                              |
+------------------------------+  <-- 栈顶 (Stack Pointer, RSP) 向下增长
|           Stack              |
|           (向下增长 ↓)         |
|                              |
|           ...                |
|                              |
+------------------------------+
|           ...                |
|           ...                |  未映射区域 (Hole / Guard Page)
+------------------------------+
|                              |
|           Heap               |
|           (向上增长 ↑)         |
|                              |
+------------------------------+  <-- 堆底 (Break, brk/sbrk 管理)
|           .bss               |  (未初始化/零初始化全局/静态变量)
+------------------------------+
|           .data              |  (初始化非零全局/静态变量)
+------------------------------+
|           .rodata            |  (只读数据, 如字符串常量) [可能合并到 .text]
+------------------------------+
|           .text              |  (程序代码, 只读)
+------------------------------+
|   程序头部等 (ELF Header)      |  低地址 (0x400000 附近)
+------------------------------+
```
.text  是可执行代码存放的位置，
.rodata 是常量部分，如字符串的值
.data 初始化的非零，存储了键值对的内存段
.bss 值为0的变量区域，存储了键
  Heap  和 stack不必多说

## 从程序调用角度理解内存块的协调配合
程序调用过程中的内存图解
```bash
高地址 (0x7fffffffffff)
+---------------------------------------+ 
|               内核空间                 | 
+---------------------------------------+ <-- 0x7fffffffffff
|                                       |
|             调用者栈帧 (Caller)        |
|              (Caller's Frame)         |
|                                       |
|  +---------------------------------+  |
|  | 调用者局部变量 (Caller's Locals)  |  | <-- 调用者EBP (Caller's EBP)
|  +---------------------------------+  |
|  | 参数区域 (Parameters Area)       |  |
|  +---------------------------------+  |
|                                       | 
+=======================================+ <-- 调用者栈顶 (Caller's ESP before call)
|             函数调用过程               |
|              (Function Call)          |
+---------------------------------------+ 
|                                       | 
|             被调用函数栈帧             |
|              (Callee Frame)           |
|                                       |
|  +---------------------------------+  | 
|  | 参数2 (Param2)                  |  | <-- [EBP + 12] 
|  +---------------------------------+  | 
|  | 参数1 (Param1)                  |  | <-- [EBP + 8]
|  +---------------------------------+  | 
|  | 返回地址 (Return Address)        |  | <-- [EBP + 4]
|  +---------------------------------+  | 
|  | 保存的EBP (Saved EBP)            |  | <-- EBP 当前指向这里 ★
|  +---------------------------------+  | 
|  | 局部变量1 (Local Var1)           |  | <-- [EBP - 4]
|  +---------------------------------+  | 
|  | 局部变量2 (Local Var2)           |  | <-- [EBP - 8]
|  +---------------------------------+  | 
|  | ... (其他局部变量)               |  | <-- ESP 当前指向这里
|  +---------------------------------+  | 
|                                       | 
+=======================================+ <-- 栈当前顶部 (Current ESP)
|             未使用栈空间               |
|              (Free Stack Space)        |
|                                       | 
+---------------------------------------+
|             堆 (Heap)                 |
|              (向上增长 ↑)               |
+---------------------------------------+
|              .bss / .data / .rodata   |
+---------------------------------------+
|              .text (代码段)            |
+---------------------------------------+
低地址 (0x400000)
```
### 📌 ​**​函数调用流程：​**​

1. 
    ​**​调用 (`call func`):​**​
    → 压入返回地址，跳转至 `func`代码。
2. 
    ​**​建立新栈帧 (序言):​**​
    → `push ebp`(保存调用者栈底)
    → `mov ebp, esp`(设置当前栈底)
    → `sub esp, N`(为局部变量腾空间)。
3. 
    ​**​执行函数体:​**​
    → 用 `[ebp + offset]`访问参数
    → 用 `[ebp - offset]`访问局部变量
    → 执行业务逻辑（.text 指令）。
4. 
    ​**​拆除栈帧 (尾声):​**​
    → `mov esp, ebp`(丢弃局部变量)
    → `pop ebp`(恢复调用者栈底)
    → `ret`(弹出返回地址，跳回调用处)。

### 注意
- 参数和局部变量中间夹着返回地址，意味着当返回地址被弹出后，参数还留在栈上，需要手动清理

## 栈溢出
32位系统示例：
- `char buffer[32]`→ 32字节
- EBP指针 → 4字节
- 总偏移 = 32 + 4 = 36字节
64位系统示例：
- `char buffer[32]`→ 32字节
- RBP指针 → 8字节
- 总偏移 = 32 + 8 = 40字节