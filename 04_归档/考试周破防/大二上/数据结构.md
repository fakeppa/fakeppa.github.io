---
tags:
icon: pen-to-square
date: 2025-12-22
title: 数据结构
category:
  - 归档
---
## 树结构的线性存储
### 1. 顺序存储法(二叉树逻辑较简单)

**根据二叉树的顺序存储规则，根节点存储在索引1（或0），对于任意节点 i，其左子节点存储在 2i 处，右子节点存储在 2i+1 处（若从0开始索引，则左子节点为 2i+1，右子节点为 2i+2）。空缺位置用0表示。**

## 2. 链式存储法（主流方法）
**存储表**（数组实现）

|索引|数据|父节点索引|
|---|---|---|
|0|A|-1|
|1|B|0|
|2|C|0|
|3|D|0|
|4|E|1|
|5|F|2|
|6|H|3|
**优点**：找父亲、找根极快。

**缺点**：找所有孩子极慢（需遍历整个表）。
写做：
![image.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png)

**2. 孩子表示法**

每个节点记录“所有孩子是谁”。
**节点数组**（顺序表）：

|索引|数据|第一个孩子指针|
|---|---|---|
|0|A|→ [1] → [2] → [3] → NULL|
|1|B|→ [4] → NULL|
|2|C|→ [5] → NULL|
|3|D|→ [6] → NULL|
|4|E|NULL|
|5|F|NULL|
|6|H|NULL|

**3. 孩子兄弟表示法（最常用、最重要）**

这是**将任意树转换为二叉树**的标准方法。每个节点包含
- `数据`
- `firstChild`：指向**第一个孩子**
- `nextSibling`：指向**下一个兄弟**

写做
![image.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png)

##  方法三：其他与高级方法

**1. 边表表示法（适用于以边为核心的操作）**

存储所有边（如`(A,B)`, `(A,C)`, `(A,D)`, `(B,E)`, `(C,F)`, `(D,H)`），再配合节点表。在图论中更常见。

**2. 邻接表（图的通用表示，树是特殊的图）**

与“孩子表示法”类似，是图的标准存储方式之一，每个节点维护一个邻居（孩子）链表。

**3. 线索二叉树（您之前问到的——这是方法的“优化”，而非独立方法）**

它建立在**孩子兄弟表示法（二叉链表）**​ 之上。通过在空指针域中存储遍历顺序下的**前驱/后继**（称为“线索”），来加速遍历操作。其底层物理结构依然是二叉链表。
#### 线索二叉树--二叉链表与双链表的结合
```c
// 线索二叉树节点结构
typedef struct ThreadNode {
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag;  // 0:指向孩子，1:指向前驱线索
    int rtag;  // 0:指向孩子，1:指向后继线索
} ThreadNode;
```
中序线索化
将二叉树转为孩子表示法，再中序遍历，将中序遍历结果作为线索
空闲的标志位在1时，前驱表示中序遍历的前驱，后继表示为中序遍历的后继