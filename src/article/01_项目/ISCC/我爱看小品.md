---
icon: pen-to-square
date: 2025-05-02
tags: 
title: 我爱看小品
category:
  - 项目
---
## 前言
首先注意版本，python版本必须为3.8才可以
## 解题过程


解压附件获得something二进制程序
需要用到`pyinstxtractor`
```bash
# 安装并运行 pyinstxtractor
git clone https://github.com/extremecoders-re/pyinstxtractor
cd pyinstxtractor
python3 pyinstxtractor.py /path/to/something

# 进入解包目录
cd something_extracted
```


解包如下图
![12df36ff1367f3fda38eebf6c486ae30.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/12df36ff1367f3fda38eebf6c486ae30.png)

命令行提示被加密
原因是在PyInstaller 打包时使用了 `--key=密钥` 参数对字节码进行了加密
### 寻找key进行脚本解密
经过搜索，发现key在
![image.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20250502140624.png)
用[在线Python pyc文件编译与反编译](https://www.lddgo.net/string/pyc-compile-decompile)进行反编译，可以直接看到源代码
![image.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20250502140813.png)
然后用脚本跑一遍解密
对应位置填写key
```python
import glob
import zlib
import tinyaes
from pathlib import Path
CRYPT_BLOCK_SIZE = 16
# key obtained from pyimod00_crypto_key
key = bytes('', 'utf-8') #在这行填写key
for p in Path("PYZ-00.pyz_extracted").glob("**/*.pyc.encrypted"):
    inf = open(p, 'rb') # encrypted file input
    outf = open(p.with_name(p.stem), 'wb') # output file
    # Initialization vector
    iv = inf.read(CRYPT_BLOCK_SIZE)
    cipher = tinyaes.AES(key, iv)
    # Decrypt and decompress
    plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))
    # Write pyc header
    # The header below is for Python 3.8
    outf.write(b'\x55\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0')
    # Write decrypted data
    outf.write(plaintext)
    inf.close()
    outf.close()
    # Delete .pyc.encrypted file
    p.unlink()
```
注意要放到something_extracted文件夹内运行脚本

### 获得flag
获得解密后的pyc，用上面提到的网站进行反编译，在PYZ-00.pyz_extracted找到mypy.py，这个是加密逻辑，并可以看到硬编码密钥
```python
# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information
# Version : Python 3.8
  
import time
  
def myfun():
    part1 = 'ISCC{'
    part2 = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxx'
    part3 = '}'
    tmp = ''
    part2_1 = part2[:11]
    part2_2 = part2[11:15]
    part2_3 = part2[15:20]
    part2_4 = part2[20:]
    for i in range(len(part2_1)):
        tmp += chr(ord(part2_1[i]) + 1)
    for i in range(len(part2_2)):
        if part2_2[i].isalpha():
            tmp += chr(ord(part2_2[i]) ^ 32)
            continue
        tmp += chr(ord(part2_2[i]) + 0)
    for i in range(len(part2_3)):
        tmp += chr(ord(part2_3[i]) - 1)
    for i in range(len(part2_4)):
        tmp += chr(ord(part2_4[i]) + i % 2)
    cipher = '你的密钥'  # 这里获得你的密钥
    true_flag = part1 + part2 + part3
    print(time.strftime('%Y-%m-%d %H:%M', time.localtime(time.time())))
    return true_flag
  
if __name__ == '__main__':
    ss = myfun()
    print(ss)
```

这是个逆向之后的程序，需要填写自己的密钥
```python
cipher = '' #自己的密钥

# 分段长度和位置
part2_1_enc = cipher[:11]
part2_2_enc = cipher[11:15]
part2_3_enc = cipher[15:20]
part2_4_enc = cipher[20:]
  
# 逆操作
part2_1 = ''.join([chr(ord(c) - 1) for c in part2_1_enc])
  
part2_2 = ''
for c in part2_2_enc:
    if c.isalpha():
        part2_2 += chr(ord(c) ^ 32)  # 大小写反转
    else:
        part2_2 += c
  
part2_3 = ''.join([chr(ord(c) + 1) for c in part2_3_enc])
  
part2_4 = ''
for i, c in enumerate(part2_4_enc):
    part2_4 += chr(ord(c) - (i % 2))
  
part2 = part2_1 + part2_2 + part2_3 + part2_4
flag = f"ISCC{{{part2}}}"
print(flag)
```

运行后获得flag