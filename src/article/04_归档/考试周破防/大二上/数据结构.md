---
tags:
icon: pen-to-square
date: 2025-12-22
title: 数据结构
category:
  - 归档
---
## 树结构的线性存储
### 1. 顺序存储法(二叉树逻辑较简单)

**根据二叉树的顺序存储规则，根节点存储在索引1（或0），对于任意节点 i，其左子节点存储在 2i 处，右子节点存储在 2i+1 处（若从0开始索引，则左子节点为 2i+1，右子节点为 2i+2）。空缺位置用0表示。**

## 2. 链式存储法（主流方法）
**存储表**（数组实现）

|索引|数据|父节点索引|
|---|---|---|
|0|A|-1|
|1|B|0|
|2|C|0|
|3|D|0|
|4|E|1|
|5|F|2|
|6|H|3|
**优点**：找父亲、找根极快。
**缺点**：找所有孩子极慢（需遍历整个表）。

写做：
![image.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png)

**2. 孩子表示法**
![image.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251224004636.png)
每个节点记录“所有孩子是谁”。
**节点数组**（顺序表）：

| 索引  | 数据  | 第一个孩子指针                  |
| --- | --- | ------------------------ |
| 0   | A   | → [1] → [2] → [3] → NULL |
| 1   | B   | → [4] → NULL             |
| 2   | C   | → [5] → NULL             |
| 3   | D   | → [6] → NULL             |
| 4   | E   | NULL                     |
| 5   | F   | NULL                     |
| 6   | H   | NULL                     |

**3. 孩子兄弟表示法（最常用、最重要）**

这是**将任意树转换为二叉树**的标准方法。每个节点包含
- `数据`
- `firstChild`：指向**第一个孩子**
- `nextSibling`：指向**下一个兄弟**

写做
![image.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png)


##  方法三：其他与高级方法

**1. 边表表示法（适用于以边为核心的操作）**

存储所有边（如`(A,B)`, `(A,C)`, `(A,D)`, `(B,E)`, `(C,F)`, `(D,H)`），再配合节点表。在图论中更常见。

**2. 邻接表（图的通用表示，树是特殊的图）**

与“孩子表示法”类似，是图的标准存储方式之一，每个节点维护一个邻居（孩子）链表。

**3. 线索二叉树（您之前问到的——这是方法的“优化”，而非独立方法）**

它建立在**孩子兄弟表示法（二叉链表）**​ 之上。通过在空指针域中存储遍历顺序下的**前驱/后继**（称为“线索”），来加速遍历操作。其底层物理结构依然是二叉链表。
#### 线索二叉树--二叉链表与双链表的结合
```c
// 线索二叉树节点结构
typedef struct ThreadNode {
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag;  // 0:指向孩子，1:指向前驱线索
    int rtag;  // 0:指向孩子，1:指向后继线索
} ThreadNode;
```

中序线索化
将二叉树转为孩子表示法，再中序遍历，将中序遍历结果作为线索
空闲的标志位在1时，前驱表示中序遍历的前驱，后继表示为中序遍历的后继
![image.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222143211.png)
#### 关于中序第一个节点的线索和最后一个节点的线索问题
##### 无头节点
第一个元素的左指针若空闲指向NULL，最后一个元素右指针若空闲也指向NULL
##### 有头节点
头节点的左指针指向第一个元素，右指针指向最后一个元素，而第一个元素指向头节点，最后一个元素指向头节点
![image.png](https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222150211.png)
## 最小生成树算法（无向图）
目标：生成的树边权和一定唯一，生成树不唯一
### 加点法
从任一顶点开始，每次选择连接已选顶点集和未选顶点集的最小权边，将该边及其连接的未选顶点加入生成树，直到所有顶点都被选中
### 加边法
将所有边按权值从小到大排序，依次选择每条边，若该边连接的两个顶点不在同一连通分量中，则加入该边，否则跳过，直到选中 n-1 条边（n 为顶点数）

## 折半查找
要求：1.必须是数组（顺序表）2.数据必须是有顺序的
1. 指定left和right指针，left指向首个元素，right指向最后一个元素，表明数组的范围
2. mid指向数组的中间位置（（left+right）/2），将我的数字与mid指向的数据进行比较
3. 如果数字比我的大，则缩小right到mid-1的位置.如果数字比我的小，则扩大left到m id+1的位置
4. 重复步骤2和4，缩小到最后，出现小数点，向下取整，然后再进行比较
	1. 如果left大于right，就是找不到了
