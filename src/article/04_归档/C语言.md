---
icon: pen-to-square
date: 2025-01-03
tags: 
title: C语言
category:
  - 归档
---
**学C**
## **Windows 操作系统架构基础​**

### 关于动态的，操作系统生成的，用于描述进程的数据结构--PEB和TEB

PEB/TEB在内存中的位置
```bash
高地址 (0x7FFFFFFF)  // 32位进程示例
+---------------------------------------+ ----
|                                       |  ^
|               内核空间                 |  |  // 禁止访问 (Inaccessible)
|                                       |  |
+=======================================+ <--- 用户/内核空间分界线 (e.g., 0x80000000)
|                                       |  |
|        用户空间共享数据页              |  |  // 所有进程共享的只读数据，如系统时间、性能计数器
|    (KUSER_SHARED_DATA, 固定地址)        |  |
|                                       |  |
+---------------------------------------+  |
|                                       |  |
|                栈 (Stack)             |  |  // 用于函数调用，向下增长 (↓)
|                 (↓ grows down)         |  |
|                                       |  |      +-----------------------+
|                                       |  |      |        TEB            |
+---------------------------------------+  |      +-----------------------+
|                 TEB 数组               |  |      | - Stack Base (栈底)   | // 线程的栈信息在这里
|   (TEB for additional threads, if any)|  |      | - Stack Limit (栈顶)  |
|                                       |  |      | - Ptr to PEB          | ---+
+---------------------------------------+  |      | - Thread ID           |    |
|                环境块                  |  |      | - LastError Value     |    |
|     (Process Environment Block, PEB)  |  |      +-----------------------+    |
|                                       |  |                                  |
|  +---------------------------------+  |  |      +-----------------------+   |
|  | PEB Contents:                   |  |  |      |        PEB            |   |
|  | - ImageBaseAddress (exe addr)   |  |  |      +-----------------------+   |
|  | - Ldr (Ptr to ---+--> PEB_LDR_DATA)|  |      | - ImageBaseAddress    |   |
|  | - ProcessParameters (CmdLine, EnvVars)| |      | - Ldr (Module Lists)  |   |
|  | - ...                          |  |  |      | - ProcessParameters   |   |
|  +---------------------------------+  |  |      | - ...                 |   |
|                                       |  |      +-----------------------+   |
+---------------------------------------+  |                                  |
|                堆 (Heap)              |  |                                  |
|    (默认进程堆 + 可选私有堆, ↑ grows up)  |  |                                  |
|                                       |  |                                  |
+---------------------------------------+  |                                  |
|        其他内存映射文件/区域            |  |  // 例如：额外的DLL、内存映射文件      |
|   (Memory Mapped Files, e.g., DLLs)    |  |                                  |
|                                       |  |                                  |
+---------------------------------------+  |                                  |
|              PE 映像 (exe)            |  |  // 您的主程序.exe文件被映射到这里     |
|   (Mapped Executable Image, .exe)     |  |  +----------------------------+  |
|                                       |  |  | .text (Code, RX)          |  |
|  +---------------------------------+  |  |  | .data (Init Data, RW)    |  |
|  | .text (Code, RX)               |  |  |  | .rdata (Const Data, R)    |  |
|  | .data (Init Data, RW)          |  |  |  | .idata (Import Table, R)  |  | // **关键：导入表在这里**
|  | .rdata (Const Data, R)         |  |  |  | .reloc (Relocations, R)   |  | // **关键：重定位表在这里**
|  | .idata (Import Table, R)       |  |  |  | ...                       |  |
|  | .reloc (Relocations, R)        |  |  |  +----------------------------+  |
|  | ...                            |  |  |                                  |
|  +---------------------------------+  |  |                                  |
|                                       |  |                                  |
+---------------------------------------+  |                                  |
|              PE 映像 (DLLs)           |  |  // 所有依赖的DLL（如kernel32.dll）   |
|    (Mapped DLL Images, .dlls)         |  |  也被映射到类似的区域，地址随机化（ASLR）|
|                                       |  |                                  |
|  +---------------------------------+  |  |                                  |
|  | .text (Code, RX)               |  |  |                                  |
|  | .data (Init Data, RW)          |  |  |                                  |
|  | .rdata (Const Data, R)         |  |  |                                  |
|  | .edata (Export Table, R)       |  |  |  // **关键：导出表在这里**           |
|  | ...                            |  |  |                                  |
|  +---------------------------------+  |  |                                  |
|                                       |  v
+---------------------------------------+ ----
低地址 (0x00010000)  // 通常从0x10000开始以避免空指针访问
```

### TEB内容描述
**PEB 和 TEB 不是静态的、只读的数据结构。它们是进程和线程运行时状态的动态反映，其内容在整个生命周期内会不断被操作系统和程序本身修改。​**
#### PEB 的动态变化 (Dynamic Changes to the PEB)
PEB 中许多字段的值在进程运行时会发生改变：

1. ​**​`Ldr`(加载器数据 - Loader Data)​**​：
    - ​**​这是最活跃的部分之一​**​。每当进程​**​动态加载​**​一个新的 DLL（例如通过 `LoadLibrary()`API）或​**​卸载​**​一个 DLL（`FreeLibrary()`）时，操作系统加载器都会​**​立即更新​**​ `PEB->Ldr`所指向的模块链表。
    - ​**​新模块的 `LDR_DATA_TABLE_ENTRY`结构会被动态创建并插入到三个链表​**​（`InLoadOrderModuleList`, `InMemoryOrderModuleList`, `InInitializationOrderModuleList`）中。反之，卸载时会被移除。
    - ​**​反调试和恶意软件分析​**​：许多软件（包括恶意软件）会遍历这个链表来检测是否有调试器相关的DLL（如 `*.dll`）被加载，或者试图隐藏自身模块。
        
    
2. ​**​`BeingDebugged`​**​：
    - 这个标志位直接由调试器操作。当一个调试器（如 OllyDbg, x64dbg, WinDbg）附加到进程时，操作系统内核会​**​将此标志设置为 1​**​。
    - 程序可以通过检查 `PEB->BeingDebugged`来执行​**​反调试​**​操作（例如，如果发现被调试就主动崩溃或改变行为）。著名的 `IsDebuggerPresent()`API 函数内部就是直接读取的这个字段。
        
    
3. ​**​`ProcessHeap`​**​：
    - 进程可以创建多个私有堆。虽然默认堆的句柄通常不变，但如果堆管理器因内存分配/释放而扩展或收缩堆的大小，其内部结构会变化，这些信息也可能间接反映出来。
        
    
4. ​**​`ProcessParameters`中的某些字段​**​：
    - 虽然命令行和环境变量通常在创建后不变，但进程完全可以调用 API 来​**​动态修改​**​当前目录等信息，这些更改会同步回 `PEB->ProcessParameters`。
        
    

#### TEB 的动态变化 (Dynamic Changes to the TEB)

TEB 的变化更加频繁，因为它与线程的执行流直接相关：
1. ​**​`LastErrorValue`​**​：
    - ​**​这是变化最频繁的字段之一​**​。几乎每次调用 Windows API 函数后，该值都可能被设置。`GetLastError()`这个 API 的本质就是直接返回 `TEB->LastErrorValue`的值。`SetLastError()`则是直接写入它。
        
    
2. ​**​栈信息 (`StackBase`, `StackLimit`)​**​：
    - 虽然栈的范围通常不会变，但随着函数调用和返回，栈指针 (`ESP/RSP`) 在不断变化。而 `TEB`本身也位于栈内存的某个区域。
        
    
3. ​**​异常处理链 (`ExceptionList`)​**​：
    - 每当线程进入一个 `__try`块或类似的异常处理结构时，编译器生成的代码会​**​将一个异常处理记录注册（压入）到 `TEB->ExceptionList`链表中​**​。离开 `__try`块时再​**​解除注册（弹出）​**​。这个链表在异常发生时被内核遍历，以决定由哪个处理程序来接管。
        
    
4. ​**​线程本地存储 (TLS) 数组​**​：
    - 线程可以通过 `TlsSetValue()`等 API 在预分配的 TLS 槽中存储数据。这些数据就存放在 TEB 的 TLS 数组里，随时可以被读写。
        
    
5. ​**​`ArbitraryUserPointer`​**​：
    - 这是一个可供程序自由使用的指针，任何线程都可以随时读写它，用于存储线程上下文的任意信息。


#### 谁在修改它们？

1. ​**​操作系统内核 (Operating System Kernel)​**​：
    
    - 这是最主要的修改者。加载DLL、附加调试器、处理异常等核心操作都是由内核发起的，内核会代表用户模式代码更新这些结构。

2. ​**​系统运行时库 (System Runtime Libraries, 如 NTDLL.dll)​**​：
    - 用户模式的系统函数（如 `LoadLibrary`, `SetLastError`）在内部最终会执行修改 PEB/TEB 的代码。

3. ​**​程序自身 (The Program Itself)​**​：

    - 程序可以​**​直接或间接​**​地修改这些结构。
    - ​**​间接​**​：通过调用官方API（如 `SetLastError`, `TlsSetValue`）。
    - ​**​直接​**​：通过​**​硬编码​**​方式直接访问和修改。例如，在汇编中：




这是C程序编译后的内存的结构
```bash
高地址 (0x7fffffffffff)
+------------------------------+
|                              |  内核空间 (Kernel Space)
|                              |  (用户程序不可访问)
+------------------------------+  <-- 0x7fffffffffff (1<<47 -1)
|           ...                |
|   环境变量 (Environment vars)  |
|   命令行参数 (Command-line args)|  栈顶 (初始时)
|                              |
+------------------------------+  <-- 栈顶 (Stack Pointer, RSP) 向下增长
|           Stack              |
|           (向下增长 ↓)         |
|                              |
|           ...                |
|                              |
+------------------------------+
|           ...                |
|           ...                |  未映射区域 (Hole / Guard Page)
+------------------------------+
|                              |
|           Heap               |
|           (向上增长 ↑)         |
|                              |
+------------------------------+  <-- 堆底 (Break, brk/sbrk 管理)
|           .bss               |  (未初始化/零初始化全局/静态变量)
+------------------------------+
|           .data              |  (初始化非零全局/静态变量)
+------------------------------+
|           .rodata            |  (只读数据, 如字符串常量) [可能合并到 .text]
+------------------------------+
|           .text              |  (程序代码, 只读)
+------------------------------+
|程序头部等 (ELF Header)LINUX系统|  低地址 (0x400000 附近)
+------------------------------+
```
.text  是可执行代码存放的位置，
.rodata 是常量部分，如字符串的值
.data 初始化的非零，存储了键值对的内存段
.bss 值为0的变量区域，存储了键
  Heap  和 stack不必多说

## 从程序调用角度理解内存块的协调配合
程序调用过程中的内存图解
```bash
高地址 (0x7fffffffffff)
+---------------------------------------+ 
|               内核空间                 | 
+---------------------------------------+ <-- 0x7fffffffffff
|                                       |
|             调用者栈帧 (Caller)        |
|              (Caller's Frame)         |
|                                       |
|  +---------------------------------+  |
|  | 调用者局部变量 (Caller's Locals)  |  | <-- 调用者EBP (Caller's EBP)
|  +---------------------------------+  |
|  | 参数区域 (Parameters Area)       |  |
|  +---------------------------------+  |
|                                       | 
+=======================================+ <-- 调用者栈顶 (Caller's ESP before call)
|             函数调用过程               |
|              (Function Call)          |
+---------------------------------------+ 
|                                       | 
|             被调用函数栈帧             |
|              (Callee Frame)           |
|                                       |
|  +---------------------------------+  | 
|  | 参数2 (Param2)                  |  | <-- [EBP + 12] 
|  +---------------------------------+  | 
|  | 参数1 (Param1)                  |  | <-- [EBP + 8]
|  +---------------------------------+  | 
|  | 返回地址 (Return Address)        |  | <-- [EBP + 4]
|  +---------------------------------+  | 
|  | 保存的EBP (Saved EBP)            |  | <-- EBP 当前指向这里 ★
|  +---------------------------------+  | 
|  | 局部变量1 (Local Var1)           |  | <-- [EBP - 4]
|  +---------------------------------+  | 
|  | 局部变量2 (Local Var2)           |  | <-- [EBP - 8]
|  +---------------------------------+  | 
|  | ... (其他局部变量)               |  | <-- ESP 当前指向这里
|  +---------------------------------+  | 
|                                       | 
+=======================================+ <-- 栈当前顶部 (Current ESP)
|             未使用栈空间               |
|              (Free Stack Space)        |
|                                       | 
+---------------------------------------+
|             堆 (Heap)                 |
|              (向上增长 ↑)               |
+---------------------------------------+
|              .bss / .data / .rodata   |
+---------------------------------------+
|              .text (代码段)            |
+---------------------------------------+
低地址 (0x400000)
```
### 📌 ​**​函数调用流程(linux)：​**​

1. 
    ​**​调用 (`call func`):​**​
    → 压入返回地址，跳转至 `func`代码。
2. 
    ​**​建立新栈帧 (序言):​**​
    → `push ebp`(保存调用者栈底)
    → `mov ebp, esp`(设置当前栈底)
    → `sub esp, N`(为局部变量腾空间)。
3. 
    ​**​执行函数体:​**​
    → 用 `[ebp + offset]`访问参数
    → 用 `[ebp - offset]`访问局部变量
    → 执行业务逻辑（.text 指令）。
4. 
    ​**​拆除栈帧 (尾声):​**​
    → `mov esp, ebp`(丢弃局部变量)
    → `pop ebp`(恢复调用者栈底)
    → `ret`(弹出返回地址，跳回调用处)。

### 注意
- 参数和局部变量中间夹着返回地址，意味着当返回地址被弹出后，参数还留在栈上，需要手动清理

## 栈溢出
32位系统示例：
- `char buffer[32]`→ 32字节
- EBP指针 → 4字节
- 总偏移 = 32 + 4 = 36字节
64位系统示例：
- `char buffer[32]`→ 32字节
- RBP指针 → 8字节
- 总偏移 = 32 + 8 = 40字节