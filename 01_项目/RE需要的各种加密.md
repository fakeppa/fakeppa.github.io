---
aliases:
tags:
cssclasses:
icon: pen-to-square
date: 2025-09-18
title: RE需要的各种加密
---
## TEA算法
### 如何理解TEA算法
想象你要加密一段秘密信息，TEA会把它切成一个个​**​8字节的小块​**​（比如像切豆腐块）。每次只处理一块。

1. **准备工作​**​：先把这8字节切成左右两半，叫​**​左变量​**​和​**​右变量​**​。同时准备好你的​**​128位密钥​**​（16字节），它也切成4小份。
    
2. ​**​开始搅拌（32轮）​**​：每一轮的操作都非常相似，就像和面一样：
    
    - 先加一勺固定的“魔法调料水”（这个水叫 ​**​delta​**​，值是 `0x9E3779B9`）。每一轮都加一勺，所以调料水越加越多。
        
    - 然后，用​**​右变量​**​（右边那半）来炒​**​左变量​**​：把右变量做一些移位操作（左移4位，右移5位），和当前的“调料水”以及密钥的第1、2份混合在一起，做复杂的异或和加法。把这个炒出来的结果，“浇”到左变量上，让左变量彻底变样。
        
    - 紧接着，用这个​**​刚更新完的左变量​**​，以完全同样的方式去炒​**​右变量​**​，并把它“浇”到右变量上。
        
    - 这样，左右变量就互相“污染”了对方一次。
        
    
3. ​**​循环往复​**​：这个互相“炒菜”的过程​**​重复整整32轮​**​。每一轮都让左右变量混合得更彻底，直到原始信息面目全非。
    
4. ​**​出锅​**​：32轮结束后，最终被彻底“炒熟”的左变量和右变量拼在一起，就形成了最终的​**​8字节密文​**​。
    

如果信息很长，有很多个8字节块，那就​**​对每一块都重复一遍​**​这个“切块->搅拌32轮->出锅”的过程。

​**​总结一下​**​：TEA加密就是一个基于​**​Feistel结构​**​的、通过​**​多轮次​**​的简单操作（加、移位、异或）进行​**​充分混合​**​，最终达到加密效果的过程。它的​**​核心特征​**​就是那32轮循环以及每轮中都会出现的​**​固定常量delta (`0x9E3779B9`)​**​。

加密一个块时，核心是进行 ​**​32轮的“搅拌”操作​**​。
### 一、核心计算要素

#### 1. 输入参数

- ​**​明文数据​**​：64位（8字节）数据块
    
    - 分为两个32位字：`v0`和 `v1`
        
    - 示例：`unsigned long EntryData[2] = {v0, v1};`
        
    
- ​**​密钥​**​：128位（16字节）密钥
    
    - 分为四个32位字：`k0, k1, k2, k3`
        
    - 示例：`unsigned long Key[4] = {k0, k1, k2, k3};`
        
    
- ​**​轮数​**​：固定32轮（标准实现）
    

#### 2. 输出结果

- ​**​密文数据​**​：64位加密结果
    
    - 同样存储为两个32位字：`v0'`和 `v1'`
        
    - 示例：`EntryData[0] = v0', EntryData[1] = v1'`
        
    

#### 3. 核心常量

- ​**​Delta (δ)​**​：`0x9E3779B9`
    
    - 黄金分割常数（2³²/φ，φ≈1.618）
        
    - 数学意义：`⌊2³² × (√5-1)/2⌋`

