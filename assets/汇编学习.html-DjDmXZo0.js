import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as i,o as n}from"./app-Kw79uFAO.js";const l={};function t(g,p){return n(),a("div",null,p[0]||(p[0]=[i('<h1 id="cpu与存储器" tabindex="-1"><a class="header-anchor" href="#cpu与存储器"><span>cpu与存储器</span></a></h1><figure><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227153707.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>cpu对外部器件读写数据工作原理，不同的机器码可以对应数据或者指令，分出了三种总线：</p><ul><li><p>cpu由地址总线发出寻址数据<br> 地址宽度由其并联的导线数决定，一个导线有0,1两种状态，宽度决定了其寻址数，为2^n</p></li><li><p>cpu经控制总线发出指令，对所在地址进行操作<br> 控制总线的宽度决定了cpu对外部器件控制的能力</p></li><li><p>内存与cpu经过数据总线来传递数据<br> 数据总线并联的导线数量决定了一次传输的位</p></li></ul><p>存储器芯片</p><ul><li>RAM:可读可写，需要通电</li><li>ROM:只读不可写，断电后不会丢失数据，可以存放bios</li></ul><p>这些存储器与cpu通过总线相连，但是cpu都把他们当做内存单元<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227154536.png" alt="image.png" loading="lazy"><br> cpu会以一定逻辑对地址进行分类<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227155020.png" alt="image.png" loading="lazy"></p><p>当我们需要对一个计算机硬件系统进行编程时，必须要了解起始地址和结束地址，以及存储器地址分配的结构</p><h1 id="cpu内部" tabindex="-1"><a class="header-anchor" href="#cpu内部"><span>cpu内部</span></a></h1><p>一个典型的cpu由运算器、控制器、寄存器等器件构成，他们之间通过内部总线连接<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227155542.png" alt="image.png" loading="lazy"></p><h2 id="_8086cpu寄存器" tabindex="-1"><a class="header-anchor" href="#_8086cpu寄存器"><span>8086cpu寄存器</span></a></h2><ol><li><p><strong>通用寄存器</strong>（8个）:</p><ul><li>AX（累加器寄存器）</li><li>BX（基地址寄存器）</li><li>CX（计数器寄存器）</li><li>DX（数据寄存器）</li><li>SP（堆栈指针寄存器）</li><li>BP（基指针寄存器）</li><li>SI（源变址寄存器）</li><li>DI（目的变址寄存器）</li></ul></li><li><p><strong>段寄存器</strong>（4个）:</p><ul><li>CS（代码段寄存器）</li><li>DS（数据段寄存器）</li><li>SS（堆栈段寄存器）</li><li>ES（附加段寄存器）</li></ul></li><li><p><strong>控制寄存器</strong>（2个）:</p><ul><li>IP（指令指针寄存器）</li><li>FLAG（标志寄存器）</li></ul></li></ol><h3 id="通用寄存器" tabindex="-1"><a class="header-anchor" href="#通用寄存器"><span>通用寄存器</span></a></h3><p>AX、BX、CX、DX用来存放一般性数据，称为通用寄存器<br> 8086由于需要对上代8位寄存器的兼容，可以把一个16进制的寄存器分为两个8进制寄存器<br> 高八位位AH寄存器，低八位为AL寄存器</p><h3 id="字节与字" tabindex="-1"><a class="header-anchor" href="#字节与字"><span>字节与字</span></a></h3><p>一个字节有八位，一个子有两个字节16位</p><h3 id="一些汇编指令" tabindex="-1"><a class="header-anchor" href="#一些汇编指令"><span>一些汇编指令</span></a></h3><p>mov a,b 相当于给变量赋值操作，b的值赋值给a<br> add a,b 相当于相加操作，相加后的结果赋值给a<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227162444.png" alt="image.png" loading="lazy"></p><ul><li>当一个寄存器存储的数据高于十六位时，为丢弃最高位的数据吗，一个十六进制数据占四个bit，所以八bit寄存器只能存放两个十六进制数据</li></ul><h3 id="_8086的寻址办法" tabindex="-1"><a class="header-anchor" href="#_8086的寻址办法"><span>8086的寻址办法</span></a></h3><p>8086有20为的地址总线，意味着总线的寻址能力达到1mb。<br> 而8086是16位结构，意味着8086内部只能一次性处理、传输、暂时存储的地址为16位，表现出的寻址能力仅为64kb<br> 所以在8086内部有一种形成20位物理地址的方法，结构如下<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227163257.png" alt="image.png" loading="lazy"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227163349.png" alt="image.png" loading="lazy"><br> 地址加法器采用：物理地址=段地址×16+偏移地址 的方法形成物理地址，加法器的工作原理如图<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227163612.png" alt="image.png" loading="lazy"><br> 还是那个算法，一个十六进制数据占4为，一个16+4=20位存储器能表示5个16进制数据，<br> 意思就是把偏移地址加入到低位<br> 总的来说，8086cpu在用20位地址总线来访问地址时，会用 基础地址+偏移地址+物理地址 的方法寻址<br> 超级形象的例子：<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227164214.png" alt="image.png" loading="lazy"><br> 当然了，不能强行将两个16进制构造出32位数据，必然会丢弃一些信息，所以，不同的两个16进制段地址 和 偏移地址 可能指向相同的20进制 物理地址</p><p><em><strong>引入段寄存器，非常关键</strong></em></p><h3 id="段寄存器" tabindex="-1"><a class="header-anchor" href="#段寄存器"><span>段寄存器</span></a></h3><p>CS：代码段寄存器<br> IP：指令指针寄存器<br> CS内容当做段地址，IP内容当做偏移地址，合成物理地址，读取存储器内容，当做指令执行</p><p>在CS和IP寄存器的驱动下，cpu执行指令的操作<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227170448.png" alt="image.png" loading="lazy"></p><hr><figure><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227170932.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>获得mov ax,0123H的指令</p><figure><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227170651.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>读取下一条指令时，IP(偏移地址+3，指向初始位置，如果指令长度为2则会自动+2)<br> 以此类推，总结是这样的<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227171549.png" alt="image.png" loading="lazy"></p><p>别看CS和IP是寄存器，但是他们不能通过mov指令来修改(cpu没有提供这样的功能)<br> 那么问题来了，如何修改呢？<br><em><strong>引入jmp指令</strong></em></p><h3 id="jmp指令" tabindex="-1"><a class="header-anchor" href="#jmp指令"><span>jmp指令</span></a></h3><p>修改CS、IP内容<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227172511.png" alt="image.png" loading="lazy"><br> 仅修改IP的内容，可用 &quot;jmp 寄存器名称的方式&quot;<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227172800.png" alt="image.png" loading="lazy"></p><h3 id="内存中的字存储" tabindex="-1"><a class="header-anchor" href="#内存中的字存储"><span>内存中的字存储</span></a></h3><p>在内存中一个地址只能存放一个8位(1字节)数据，但是cpu寄存器是存放16(2字节)位数据的，当我们的寄存器访问内存时，会将低八位和高八位两个内存地址的数据进行传输<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241231200902.png" alt="image.png" loading="lazy"></p><h3 id="数据段" tabindex="-1"><a class="header-anchor" href="#数据段"><span>数据段</span></a></h3><p>可以根据需要将一段内存单元定义为数据段，在寄存器DS中存放数据段的段地址<br> 在意这样的形式对数据段的内容进行读取<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20250102183606.png" alt="image.png" loading="lazy"><br> 在8086cpu中可以通过mov直接对内存单元进行访问，就是说x86架构中CPU可以直接对内存进行操作<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20250102184200.png" alt="image.png" loading="lazy"></p><h3 id="栈" tabindex="-1"><a class="header-anchor" href="#栈"><span>栈</span></a></h3><p>栈是一种具有特殊的访问方式的存储空间<br> 最后进入这个空间的数据，最先出去<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20250102185638.png" alt="image.png" loading="lazy"><br> 准确的理解何为栈，栈顶是变化的，总有一个指针会指向栈顶</p><h3 id="cpu提供的栈机制" tabindex="-1"><a class="header-anchor" href="#cpu提供的栈机制"><span>cpu提供的栈机制</span></a></h3><p>有两个寄存器对栈内存进行指示--SS和SP，任意时刻，SS：SP指向栈顶元素<br> 入栈时，栈顶从高地址向低地址方向延伸<br> 当入栈被执行时，首先减去数据占用的内存空间，然后指向新的栈顶，最后存储低位和高位数据</p><h3 id="栈顶超界问题" tabindex="-1"><a class="header-anchor" href="#栈顶超界问题"><span>栈顶超界问题</span></a></h3><p>8086cpu不能处理栈顶超上界和下界的问题</p><h3 id="push和pop指令" tabindex="-1"><a class="header-anchor" href="#push和pop指令"><span>push和pop指令</span></a></h3><p>push和pop不仅可以对寄存器操作还可以对内存单元操作，以字为单位（两个字节为一字，也就是两个内存地址）<br> 执行push指令时，先将SP的值-2<br> 再进行数据写入，高位写入高地址，低位写入低地址<br> 执行pop命令时，先从SS:SP进行读取值，再进行SP=SP+2</p>',47)]))}const c=e(l,[["render",t],["__file","汇编学习.html.vue"]]),h=JSON.parse('{"path":"/article/01_%E9%A1%B9%E7%9B%AE/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0.html","title":"汇编学习","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-12-27T00:00:00.000Z","tags":null,"title":"汇编学习","category":["项目"],"description":"cpu与存储器 image.pngimage.png cpu对外部器件读写数据工作原理，不同的机器码可以对应数据或者指令，分出了三种总线： cpu由地址总线发出寻址数据 地址宽度由其并联的导线数决定，一个导线有0,1两种状态，宽度决定了其寻址数，为2^n cpu经控制总线发出指令，对所在地址进行操作 控制总线的宽度决定了cpu对外部器件控制的能力 内存...","head":[["meta",{"property":"og:url","content":"https://github.com/fakeppa/fakeppa.github.io/article/01_%E9%A1%B9%E7%9B%AE/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0.html"}],["meta",{"property":"og:site_name","content":"问己"}],["meta",{"property":"og:title","content":"汇编学习"}],["meta",{"property":"og:description","content":"cpu与存储器 image.pngimage.png cpu对外部器件读写数据工作原理，不同的机器码可以对应数据或者指令，分出了三种总线： cpu由地址总线发出寻址数据 地址宽度由其并联的导线数决定，一个导线有0,1两种状态，宽度决定了其寻址数，为2^n cpu经控制总线发出指令，对所在地址进行操作 控制总线的宽度决定了cpu对外部器件控制的能力 内存..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227153707.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-14T17:34:15.000Z"}],["meta",{"property":"article:published_time","content":"2024-12-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-14T17:34:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"汇编学习\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227153707.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227154536.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227155020.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227155542.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227162444.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227163257.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227163349.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227163612.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227164214.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227170448.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227170932.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227170651.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227171549.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227172511.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227172800.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241231200902.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20250102183606.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20250102184200.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20250102185638.png\\"],\\"datePublished\\":\\"2024-12-27T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-14T17:34:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"fakeppa\\",\\"url\\":\\"https://github.com/fakeppa/fakeppa.github.io\\"}]}"]]},"headers":[{"level":2,"title":"8086cpu寄存器","slug":"_8086cpu寄存器","link":"#_8086cpu寄存器","children":[{"level":3,"title":"通用寄存器","slug":"通用寄存器","link":"#通用寄存器","children":[]},{"level":3,"title":"字节与字","slug":"字节与字","link":"#字节与字","children":[]},{"level":3,"title":"一些汇编指令","slug":"一些汇编指令","link":"#一些汇编指令","children":[]},{"level":3,"title":"8086的寻址办法","slug":"_8086的寻址办法","link":"#_8086的寻址办法","children":[]},{"level":3,"title":"段寄存器","slug":"段寄存器","link":"#段寄存器","children":[]},{"level":3,"title":"jmp指令","slug":"jmp指令","link":"#jmp指令","children":[]},{"level":3,"title":"内存中的字存储","slug":"内存中的字存储","link":"#内存中的字存储","children":[]},{"level":3,"title":"数据段","slug":"数据段","link":"#数据段","children":[]},{"level":3,"title":"栈","slug":"栈","link":"#栈","children":[]},{"level":3,"title":"cpu提供的栈机制","slug":"cpu提供的栈机制","link":"#cpu提供的栈机制","children":[]},{"level":3,"title":"栈顶超界问题","slug":"栈顶超界问题","link":"#栈顶超界问题","children":[]},{"level":3,"title":"push和pop指令","slug":"push和pop指令","link":"#push和pop指令","children":[]}]}],"git":{"createdTime":1736749739000,"updatedTime":1757871255000,"contributors":[{"name":"fakeppa","username":"fakeppa","email":"l17091799155@qq.com","commits":1006,"url":"https://github.com/fakeppa"}]},"readingTime":{"minutes":5.64,"words":1692},"filePathRelative":"article/01_项目/汇编/汇编学习.md","localizedDate":"2024年12月27日","excerpt":"\\n<figure><img src=\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20241227153707.png\\" alt=\\"image.png\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>image.png</figcaption></figure>\\n<p>cpu对外部器件读写数据工作原理，不同的机器码可以对应数据或者指令，分出了三种总线：</p>\\n<ul>\\n<li>\\n<p>cpu由地址总线发出寻址数据<br>\\n地址宽度由其并联的导线数决定，一个导线有0,1两种状态，宽度决定了其寻址数，为2^n</p>\\n</li>\\n<li>\\n<p>cpu经控制总线发出指令，对所在地址进行操作<br>\\n控制总线的宽度决定了cpu对外部器件控制的能力</p>\\n</li>\\n<li>\\n<p>内存与cpu经过数据总线来传递数据<br>\\n数据总线并联的导线数量决定了一次传输的位</p>\\n</li>\\n</ul>","autoDesc":true}');export{c as comp,h as data};
