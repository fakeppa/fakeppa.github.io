import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,b as a,o as l}from"./app-DU_c6yRs.js";const n={};function s(d,t){return l(),e("div",null,t[0]||(t[0]=[a(`<h2 id="考纲" tabindex="-1"><a class="header-anchor" href="#考纲"><span>考纲</span></a></h2><h3 id="第一章" tabindex="-1"><a class="header-anchor" href="#第一章"><span>第一章</span></a></h3><p>理解，可能考选择题，定义考选择题</p><h3 id="第二章" tabindex="-1"><a class="header-anchor" href="#第二章"><span>第二章</span></a></h3><p>小题</p><ol><li>顺序表</li><li>单链表</li><li>链表</li><li>线性表</li></ol><h3 id="第三章" tabindex="-1"><a class="header-anchor" href="#第三章"><span>第三章</span></a></h3><p>小题</p><ol><li>栈</li><li>队列</li></ol><h3 id="第七章-重点" tabindex="-1"><a class="header-anchor" href="#第七章-重点"><span>第七章（重点）</span></a></h3><p>树的性质--&gt;计算<br> 大题</p><ol><li>二叉树线序，中序，后序遍历</li><li>线索二叉树</li><li>画哈夫曼树，哈夫曼编码</li></ol><h3 id="第八章-重重点" tabindex="-1"><a class="header-anchor" href="#第八章-重重点"><span>第八章(重重点)</span></a></h3><ol><li>图的存储结构<br> 大题</li><li>图的遍历(重点) <ol><li>深度优先遍历</li><li>广度优先遍历<br> 最小生成树 <ol><li>普利姆算法prim</li><li>克鲁斯卡尔算法kruskal</li></ol></li></ol></li></ol><p>最短路径（必考）<br> Dijkstra算法<br> AOE网（小题）</p><h2 id="第九章" tabindex="-1"><a class="header-anchor" href="#第九章"><span>第九章</span></a></h2><p>线性表的查找<br> 1. 顺序查找<br> 2. 折半查找<br> 二叉排序树（大题）<br> 平衡二叉树要知道<br> 哈希表的查找:哈希冲突</p><h3 id="第十章" tabindex="-1"><a class="header-anchor" href="#第十章"><span>第十章</span></a></h3><h2 id="树结构的线性存储" tabindex="-1"><a class="header-anchor" href="#树结构的线性存储"><span>树结构的线性存储</span></a></h2><h3 id="_1-顺序存储法-二叉树逻辑较简单" tabindex="-1"><a class="header-anchor" href="#_1-顺序存储法-二叉树逻辑较简单"><span>1. 顺序存储法(二叉树逻辑较简单)</span></a></h3><p><strong>根据二叉树的顺序存储规则，根节点存储在索引1（或0），对于任意节点 i，其左子节点存储在 2i 处，右子节点存储在 2i+1 处（若从0开始索引，则左子节点为 2i+1，右子节点为 2i+2）。空缺位置用0表示。</strong></p><h2 id="_2-链式存储法-主流方法" tabindex="-1"><a class="header-anchor" href="#_2-链式存储法-主流方法"><span>2. 链式存储法（主流方法）</span></a></h2><p><strong>存储表</strong>（数组实现）</p><table><thead><tr><th>索引</th><th>数据</th><th>父节点索引</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>-1</td></tr><tr><td>1</td><td>B</td><td>0</td></tr><tr><td>2</td><td>C</td><td>0</td></tr><tr><td>3</td><td>D</td><td>0</td></tr><tr><td>4</td><td>E</td><td>1</td></tr><tr><td>5</td><td>F</td><td>2</td></tr><tr><td>6</td><td>H</td><td>3</td></tr><tr><td><strong>优点</strong>：找父亲、找根极快。</td><td></td><td></td></tr><tr><td><strong>缺点</strong>：找所有孩子极慢（需遍历整个表）。</td><td></td><td></td></tr></tbody></table><p>写做：<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png" alt="image.png" loading="lazy"></p><p><strong>2. 孩子表示法</strong><br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251224004636.png" alt="image.png" loading="lazy"><br> 每个节点记录“所有孩子是谁”。<br><strong>节点数组</strong>（顺序表）：</p><table><thead><tr><th>索引</th><th>数据</th><th>第一个孩子指针</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>→ [1] → [2] → [3] → NULL</td></tr><tr><td>1</td><td>B</td><td>→ [4] → NULL</td></tr><tr><td>2</td><td>C</td><td>→ [5] → NULL</td></tr><tr><td>3</td><td>D</td><td>→ [6] → NULL</td></tr><tr><td>4</td><td>E</td><td>NULL</td></tr><tr><td>5</td><td>F</td><td>NULL</td></tr><tr><td>6</td><td>H</td><td>NULL</td></tr></tbody></table><p><strong>3. 孩子兄弟表示法（最常用、最重要）</strong></p><p>这是<strong>将任意树转换为二叉树</strong>的标准方法。每个节点包含</p><ul><li><code>数据</code></li><li><code>firstChild</code>：指向<strong>第一个孩子</strong></li><li><code>nextSibling</code>：指向<strong>下一个兄弟</strong></li></ul><p>写做<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png" alt="image.png" loading="lazy"></p><h2 id="方法三-其他与高级方法" tabindex="-1"><a class="header-anchor" href="#方法三-其他与高级方法"><span>方法三：其他与高级方法</span></a></h2><p><strong>1. 边表表示法（适用于以边为核心的操作）</strong></p><p>存储所有边（如<code>(A,B)</code>, <code>(A,C)</code>, <code>(A,D)</code>, <code>(B,E)</code>, <code>(C,F)</code>, <code>(D,H)</code>），再配合节点表。在图论中更常见。</p><p><strong>2. 邻接表（图的通用表示，树是特殊的图）</strong></p><p>与“孩子表示法”类似，是图的标准存储方式之一，每个节点维护一个邻居（孩子）链表。</p><p><strong>3. 线索二叉树（您之前问到的——这是方法的“优化”，而非独立方法）</strong></p><p>它建立在<strong>孩子兄弟表示法（二叉链表）<strong>​ 之上。通过在空指针域中存储遍历顺序下的</strong>前驱/后继</strong>（称为“线索”），来加速遍历操作。其底层物理结构依然是二叉链表。</p><h4 id="线索二叉树-二叉链表与双链表的结合" tabindex="-1"><a class="header-anchor" href="#线索二叉树-二叉链表与双链表的结合"><span>线索二叉树--二叉链表与双链表的结合</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 线索二叉树节点结构</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ElemType data;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lchild, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">rchild;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ltag;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 0:指向孩子，1:指向前驱线索</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> rtag;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 0:指向孩子，1:指向后继线索</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} ThreadNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>中序线索化<br> 将二叉树转为孩子表示法，再中序遍历，将中序遍历结果作为线索<br> 空闲的标志位在1时，前驱表示中序遍历的前驱，后继表示为中序遍历的后继<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222143211.png" alt="image.png" loading="lazy"></p><h4 id="关于中序第一个节点的线索和最后一个节点的线索问题" tabindex="-1"><a class="header-anchor" href="#关于中序第一个节点的线索和最后一个节点的线索问题"><span>关于中序第一个节点的线索和最后一个节点的线索问题</span></a></h4><h5 id="无头节点" tabindex="-1"><a class="header-anchor" href="#无头节点"><span>无头节点</span></a></h5><p>第一个元素的左指针若空闲指向NULL，最后一个元素右指针若空闲也指向NULL</p><h5 id="有头节点" tabindex="-1"><a class="header-anchor" href="#有头节点"><span>有头节点</span></a></h5><p>头节点的左指针指向第一个元素，右指针指向最后一个元素，而第一个元素指向头节点，最后一个元素指向头节点<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222150211.png" alt="image.png" loading="lazy"></p><h2 id="最小生成树算法-无向图" tabindex="-1"><a class="header-anchor" href="#最小生成树算法-无向图"><span>最小生成树算法（无向图）</span></a></h2><p>目标：生成的树边权和一定唯一，生成树不唯一</p><h3 id="加点法-普利姆算法" tabindex="-1"><a class="header-anchor" href="#加点法-普利姆算法"><span>加点法----普利姆算法</span></a></h3><p>从任一顶点开始，每次选择连接已选顶点集和未选顶点集的最小权边，将该边及其连接的未选顶点加入生成树，直到所有顶点都被选中</p><h3 id="加边法-克鲁斯卡尔算法" tabindex="-1"><a class="header-anchor" href="#加边法-克鲁斯卡尔算法"><span>加边法----克鲁斯卡尔算法</span></a></h3><p>将所有边按权值从小到大排序，依次选择每条边，若该边连接的两个顶点不在同一连通分量中，则加入该边，否则跳过，直到选中 n-1 条边（n 为顶点数）</p><h2 id="折半查找" tabindex="-1"><a class="header-anchor" href="#折半查找"><span>折半查找</span></a></h2><p>要求：1.必须是数组（顺序表）2.数据必须是有顺序的</p><ol><li>指定left和right指针，left指向首个元素，right指向最后一个元素，表明数组的范围</li><li>mid指向数组的中间位置（（left+right）/2），将我的数字与mid指向的数据进行比较</li><li>如果数字比我的大，则缩小right到mid-1的位置.如果数字比我的小，则扩大left到m id+1的位置</li><li>重复步骤2和4，缩小到最后，出现小数点，向下取整，然后再进行比较 <ol><li>如果left大于right，就是找不到了</li></ol></li></ol>`,55)]))}const p=i(n,[["render",s],["__file","数据结构.html.vue"]]),o=JSON.parse('{"path":"/article/04_%E5%BD%92%E6%A1%A3/%E8%80%83%E8%AF%95%E5%91%A8%E7%A0%B4%E9%98%B2/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"数据结构","lang":"zh-CN","frontmatter":{"tags":null,"icon":"pen-to-square","date":"2025-12-22T00:00:00.000Z","title":"数据结构","category":["归档"],"description":"考纲 第一章 理解，可能考选择题，定义考选择题 第二章 小题 顺序表 单链表 链表 线性表 第三章 小题 栈 队列 第七章（重点） 树的性质-->计算 大题 二叉树线序，中序，后序遍历 线索二叉树 画哈夫曼树，哈夫曼编码 第八章(重重点) 图的存储结构 大题 图的遍历(重点) 深度优先遍历 广度优先遍历 最小生成树 普利姆算法prim 克鲁斯卡尔算法k...","head":[["meta",{"property":"og:url","content":"https://github.com/fakeppa/fakeppa.github.io/article/04_%E5%BD%92%E6%A1%A3/%E8%80%83%E8%AF%95%E5%91%A8%E7%A0%B4%E9%98%B2/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"问己"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:description","content":"考纲 第一章 理解，可能考选择题，定义考选择题 第二章 小题 顺序表 单链表 链表 线性表 第三章 小题 栈 队列 第七章（重点） 树的性质-->计算 大题 二叉树线序，中序，后序遍历 线索二叉树 画哈夫曼树，哈夫曼编码 第八章(重重点) 图的存储结构 大题 图的遍历(重点) 深度优先遍历 广度优先遍历 最小生成树 普利姆算法prim 克鲁斯卡尔算法k..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-24T06:56:54.000Z"}],["meta",{"property":"article:published_time","content":"2025-12-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-24T06:56:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251224004636.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222143211.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222150211.png\\"],\\"datePublished\\":\\"2025-12-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-24T06:56:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"fakeppa\\",\\"url\\":\\"https://github.com/fakeppa/fakeppa.github.io\\"}]}"]]},"headers":[{"level":2,"title":"考纲","slug":"考纲","link":"#考纲","children":[{"level":3,"title":"第一章","slug":"第一章","link":"#第一章","children":[]},{"level":3,"title":"第二章","slug":"第二章","link":"#第二章","children":[]},{"level":3,"title":"第三章","slug":"第三章","link":"#第三章","children":[]},{"level":3,"title":"第七章（重点）","slug":"第七章-重点","link":"#第七章-重点","children":[]},{"level":3,"title":"第八章(重重点)","slug":"第八章-重重点","link":"#第八章-重重点","children":[]}]},{"level":2,"title":"第九章","slug":"第九章","link":"#第九章","children":[{"level":3,"title":"第十章","slug":"第十章","link":"#第十章","children":[]}]},{"level":2,"title":"树结构的线性存储","slug":"树结构的线性存储","link":"#树结构的线性存储","children":[{"level":3,"title":"1. 顺序存储法(二叉树逻辑较简单)","slug":"_1-顺序存储法-二叉树逻辑较简单","link":"#_1-顺序存储法-二叉树逻辑较简单","children":[]}]},{"level":2,"title":"2. 链式存储法（主流方法）","slug":"_2-链式存储法-主流方法","link":"#_2-链式存储法-主流方法","children":[]},{"level":2,"title":"方法三：其他与高级方法","slug":"方法三-其他与高级方法","link":"#方法三-其他与高级方法","children":[]},{"level":2,"title":"最小生成树算法（无向图）","slug":"最小生成树算法-无向图","link":"#最小生成树算法-无向图","children":[{"level":3,"title":"加点法----普利姆算法","slug":"加点法-普利姆算法","link":"#加点法-普利姆算法","children":[]},{"level":3,"title":"加边法----克鲁斯卡尔算法","slug":"加边法-克鲁斯卡尔算法","link":"#加边法-克鲁斯卡尔算法","children":[]}]},{"level":2,"title":"折半查找","slug":"折半查找","link":"#折半查找","children":[]}],"git":{"createdTime":1766383909000,"updatedTime":1766559414000,"contributors":[{"name":"fakeppa","username":"fakeppa","email":"l17091799155@qq.com","commits":20,"url":"https://github.com/fakeppa"}]},"readingTime":{"minutes":4.36,"words":1307},"filePathRelative":"article/04_归档/考试周破防/大二上/数据结构.md","localizedDate":"2025年12月22日","excerpt":"<h2>考纲</h2>\\n<h3>第一章</h3>\\n<p>理解，可能考选择题，定义考选择题</p>\\n<h3>第二章</h3>\\n<p>小题</p>\\n<ol>\\n<li>顺序表</li>\\n<li>单链表</li>\\n<li>链表</li>\\n<li>线性表</li>\\n</ol>\\n<h3>第三章</h3>\\n<p>小题</p>\\n<ol>\\n<li>栈</li>\\n<li>队列</li>\\n</ol>\\n<h3>第七章（重点）</h3>\\n<p>树的性质--&gt;计算<br>\\n大题</p>\\n<ol>\\n<li>二叉树线序，中序，后序遍历</li>\\n<li>线索二叉树</li>\\n<li>画哈夫曼树，哈夫曼编码</li>\\n</ol>","autoDesc":true}');export{p as comp,o as data};
