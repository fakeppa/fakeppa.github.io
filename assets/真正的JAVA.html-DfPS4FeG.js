import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as r,o as p}from"./app-d61jXsMZ.js";const o={};function i(n,e){return p(),a("div",null,e[0]||(e[0]=[r('<h1 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象"><span>面向对象</span></a></h1><p>类是创建对象的模版：（以一套特定的规则来创建对象的模版）<br> 对象是类的实例（在特定的规则下所创建的对象）</p><p>#非primitive变量只会将变量名保存在栈上，而对象在堆上</p><p>子类继承的方法可以被覆盖，实例变量不可以被覆盖</p><h2 id="super关键字-了解了前两个使用方法" tabindex="-1"><a class="header-anchor" href="#super关键字-了解了前两个使用方法"><span>super关键字(了解了前两个使用方法)</span></a></h2><p>在 Java 中，<code>super</code> 关键字是一个非常重要的概念，主要用于访问父类的属性和方法。它在继承关系中起着关键作用，允许子类与父类之间进行交互。以下是对 <code>super</code> 关键字的详细解释：</p><h3 id="_1-访问父类的属性" tabindex="-1"><a class="header-anchor" href="#_1-访问父类的属性"><span>1. 访问父类的属性</span></a></h3><p>当子类和父类中有同名的实例变量时，可以使用 <code>super</code> 关键字来区分它们。通过 <code>super</code>，子类可以访问父类的实例变量。</p><h3 id="_2-访问父类的方法" tabindex="-1"><a class="header-anchor" href="#_2-访问父类的方法"><span>2. 访问父类的方法</span></a></h3><p>如果子类重写了父类的方法，但在某些情况下仍然需要调用父类的方法，可以使用 <code>super</code> 关键字来实现。</p><h3 id="_3-调用父类的构造函数" tabindex="-1"><a class="header-anchor" href="#_3-调用父类的构造函数"><span>3. 调用父类的构造函数</span></a></h3><p>在子类的构造函数中，可以使用 <code>super()</code> 来调用父类的构造函数。这通常用于初始化父类的属性。</p><h2 id="this关键字" tabindex="-1"><a class="header-anchor" href="#this关键字"><span>this关键字：</span></a></h2><p>前提：this的使用在一个方法里，且存在一个类，用this.变量名来访问实例变量的值<br> 目的：改变实例变量，然后可以用改变后的实例变量进行操作</p><h1 id="new关键字" tabindex="-1"><a class="header-anchor" href="#new关键字"><span>new关键字：</span></a></h1><p>格式：类名 对象名(这会将dog类的实例化对象的引用传递给这个变量名，即可以将此变量名当成类名使用) = new 方法名(在指定类中的方法) 参数</p><h1 id="自动调用setter或getter的条件" tabindex="-1"><a class="header-anchor" href="#自动调用setter或getter的条件"><span>自动调用setter或getter的条件</span></a></h1><ul><li>其中 getter 方法需满足条件：方法名长于 4、不是静态方法、以 <code>get</code> 开头且第4位是大写字母、方法不能有参数传入、继承自特定类，此属性没有 setter 方法；<br> 特定类：<code>Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong</code></li><li>setter 方法需满足条件：方法名长于 4，以 <code>set</code> 开头且第4位是大写字母、非静态方法、返回类型为 void 或当前类、参数个数为 1 个。具体逻辑在 <code>com.alibaba.fastjson.util.JavaBeanInfo.build()</code> 中。<br> 若是没有setter方法，依旧想在反序列化时给变量赋值，则用<code>Feature.SupportNonPublicField</code> 参数。<br> fastjson因为引进了AutoType功能，在对json字符串反序列化的时候，会读取到type到内容，将json内容反序列化为java对象并<strong>调用这个类的setter方法。</strong></li></ul>',18)]))}const l=t(o,[["render",i],["__file","真正的JAVA.html.vue"]]),d=JSON.parse('{"path":"/article/04_%E5%BD%92%E6%A1%A3/%E7%9C%9F%E6%AD%A3%E7%9A%84JAVA.html","title":"真正的JAVA","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-01-12T00:00:00.000Z","tags":null,"title":"真正的JAVA","category":["归档"],"description":"面向对象 类是创建对象的模版：（以一套特定的规则来创建对象的模版） 对象是类的实例（在特定的规则下所创建的对象） #非primitive变量只会将变量名保存在栈上，而对象在堆上 子类继承的方法可以被覆盖，实例变量不可以被覆盖 super关键字(了解了前两个使用方法) 在 Java 中，super 关键字是一个非常重要的概念，主要用于访问父类的属性和方法...","head":[["meta",{"property":"og:url","content":"https://github.com/fakeppa/fakeppa.github.io/article/04_%E5%BD%92%E6%A1%A3/%E7%9C%9F%E6%AD%A3%E7%9A%84JAVA.html"}],["meta",{"property":"og:site_name","content":"问己"}],["meta",{"property":"og:title","content":"真正的JAVA"}],["meta",{"property":"og:description","content":"面向对象 类是创建对象的模版：（以一套特定的规则来创建对象的模版） 对象是类的实例（在特定的规则下所创建的对象） #非primitive变量只会将变量名保存在栈上，而对象在堆上 子类继承的方法可以被覆盖，实例变量不可以被覆盖 super关键字(了解了前两个使用方法) 在 Java 中，super 关键字是一个非常重要的概念，主要用于访问父类的属性和方法..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-22T05:12:36.000Z"}],["meta",{"property":"article:published_time","content":"2025-01-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-22T05:12:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"真正的JAVA\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-01-12T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-22T05:12:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"fakeppa\\",\\"url\\":\\"https://github.com/fakeppa/fakeppa.github.io\\"}]}"]]},"headers":[{"level":2,"title":"super关键字(了解了前两个使用方法)","slug":"super关键字-了解了前两个使用方法","link":"#super关键字-了解了前两个使用方法","children":[{"level":3,"title":"1. 访问父类的属性","slug":"_1-访问父类的属性","link":"#_1-访问父类的属性","children":[]},{"level":3,"title":"2. 访问父类的方法","slug":"_2-访问父类的方法","link":"#_2-访问父类的方法","children":[]},{"level":3,"title":"3. 调用父类的构造函数","slug":"_3-调用父类的构造函数","link":"#_3-调用父类的构造函数","children":[]}]},{"level":2,"title":"this关键字：","slug":"this关键字","link":"#this关键字","children":[]}],"git":{"createdTime":1752377758000,"updatedTime":1763788356000,"contributors":[{"name":"fakeppa","username":"fakeppa","email":"l17091799155@qq.com","commits":395,"url":"https://github.com/fakeppa"}]},"readingTime":{"minutes":2.25,"words":674},"filePathRelative":"article/04_归档/真正的JAVA.md","localizedDate":"2025年1月12日","excerpt":"\\n<p>类是创建对象的模版：（以一套特定的规则来创建对象的模版）<br>\\n对象是类的实例（在特定的规则下所创建的对象）</p>\\n<p>#非primitive变量只会将变量名保存在栈上，而对象在堆上</p>\\n<p>子类继承的方法可以被覆盖，实例变量不可以被覆盖</p>\\n<h2>super关键字(了解了前两个使用方法)</h2>\\n<p>在 Java 中，<code>super</code>&nbsp;关键字是一个非常重要的概念，主要用于访问父类的属性和方法。它在继承关系中起着关键作用，允许子类与父类之间进行交互。以下是对&nbsp;<code>super</code>&nbsp;关键字的详细解释：</p>","autoDesc":true}');export{l as comp,d as data};
