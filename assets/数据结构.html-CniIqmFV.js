import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as n,o as r}from"./app-CJqu59OB.js";const l={};function e(a,t){return r(),s("div",null,t[0]||(t[0]=[n(`<h2 id="考纲" tabindex="-1"><a class="header-anchor" href="#考纲"><span>考纲</span></a></h2><p>题型分类</p><p>章节</p><p>核心考点/题型说明</p><p>**大题 (重点)**​</p><p><strong>第七章 树</strong>​</p><ol><li><strong>二叉树遍历</strong>（先/中/后序）</li><li><strong>线索二叉树</strong></li><li><strong>哈夫曼树与编码</strong>（画树、写编码）</li><li>树的性质计算</li></ol><p><strong>第八章 图</strong>​</p><ol><li><strong>图的遍历</strong>（深度优先DFS、广度优先BFS）</li><li><strong>最小生成树</strong>（Prim算法, Kruskal算法）</li><li><strong>最短路径</strong>（<strong>Dijkstra算法，必考</strong>）</li><li>图的存储结构</li></ol><p><strong>第九章 查找</strong>​</p><ol><li><strong>二叉排序树</strong>（构建、插入、删除等）</li><li>平衡二叉树（了解概念）</li><li>哈希表（冲突处理）</li></ol><p>**程序题 (代码)**​</p><p><strong>第九章 查找</strong>​</p><p><strong>程序填空/选择大题</strong>：</p><ul><li>顺序查找</li><li>折半查找</li></ul><p><strong>第十章 排序</strong>​</p><p><strong>程序填空/选择大题</strong>：</p><ul><li>直接插入排序</li><li>折半插入排序</li></ul><p>**小题 (概念/基础)**​</p><p><strong>第一章 绪论</strong>​</p><p>选择题：基本概念、定义</p><p><strong>第二章 线性表</strong>​</p><p>小题：顺序表、单链表、链表、线性表的相关基础操作与概念</p><p><strong>第三章 栈和队列</strong>​</p><p>小题：栈与队列的基本特性、操作</p><p><strong>第八章 图</strong>​</p><p>小题：AOE网的相关概<br> 念</p><h2 id="树结构的线性存储" tabindex="-1"><a class="header-anchor" href="#树结构的线性存储"><span>树结构的线性存储</span></a></h2><h3 id="_1-顺序存储法-二叉树逻辑较简单" tabindex="-1"><a class="header-anchor" href="#_1-顺序存储法-二叉树逻辑较简单"><span>1. 顺序存储法(二叉树逻辑较简单)</span></a></h3><p><strong>根据二叉树的顺序存储规则，根节点存储在索引1（或0），对于任意节点 i，其左子节点存储在 2i 处，右子节点存储在 2i+1 处（若从0开始索引，则左子节点为 2i+1，右子节点为 2i+2）。空缺位置用0表示。</strong></p><h2 id="_2-链式存储法-主流方法" tabindex="-1"><a class="header-anchor" href="#_2-链式存储法-主流方法"><span>2. 链式存储法（主流方法）</span></a></h2><p><strong>存储表</strong>（数组实现）</p><table><thead><tr><th>索引</th><th>数据</th><th>父节点索引</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>-1</td></tr><tr><td>1</td><td>B</td><td>0</td></tr><tr><td>2</td><td>C</td><td>0</td></tr><tr><td>3</td><td>D</td><td>0</td></tr><tr><td>4</td><td>E</td><td>1</td></tr><tr><td>5</td><td>F</td><td>2</td></tr><tr><td>6</td><td>H</td><td>3</td></tr><tr><td><strong>优点</strong>：找父亲、找根极快。</td><td></td><td></td></tr><tr><td><strong>缺点</strong>：找所有孩子极慢（需遍历整个表）。</td><td></td><td></td></tr></tbody></table><p>写做：<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png" alt="image.png" loading="lazy"></p><p><strong>2. 孩子表示法</strong><br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251224004636.png" alt="image.png" loading="lazy"><br> 每个节点记录“所有孩子是谁”。<br><strong>节点数组</strong>（顺序表）：</p><table><thead><tr><th>索引</th><th>数据</th><th>第一个孩子指针</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>→ [1] → [2] → [3] → NULL</td></tr><tr><td>1</td><td>B</td><td>→ [4] → NULL</td></tr><tr><td>2</td><td>C</td><td>→ [5] → NULL</td></tr><tr><td>3</td><td>D</td><td>→ [6] → NULL</td></tr><tr><td>4</td><td>E</td><td>NULL</td></tr><tr><td>5</td><td>F</td><td>NULL</td></tr><tr><td>6</td><td>H</td><td>NULL</td></tr></tbody></table><p><strong>3. 孩子兄弟表示法（最常用、最重要）</strong></p><p>这是<strong>将任意树转换为二叉树</strong>的标准方法。每个节点包含</p><ul><li><code>数据</code></li><li><code>firstChild</code>：指向<strong>第一个孩子</strong></li><li><code>nextSibling</code>：指向<strong>下一个兄弟</strong></li></ul><p>写做<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png" alt="image.png" loading="lazy"></p><h2 id="方法三-其他与高级方法" tabindex="-1"><a class="header-anchor" href="#方法三-其他与高级方法"><span>方法三：其他与高级方法</span></a></h2><p><strong>1. 边表表示法（适用于以边为核心的操作）</strong></p><p>存储所有边（如<code>(A,B)</code>, <code>(A,C)</code>, <code>(A,D)</code>, <code>(B,E)</code>, <code>(C,F)</code>, <code>(D,H)</code>），再配合节点表。在图论中更常见。</p><p><strong>2. 邻接表（图的通用表示，树是特殊的图）</strong></p><p>与“孩子表示法”类似，是图的标准存储方式之一，每个节点维护一个邻居（孩子）链表。</p><p><strong>3. 线索二叉树（您之前问到的——这是方法的“优化”，而非独立方法）</strong></p><p>它建立在<strong>孩子兄弟表示法（二叉链表）<strong>​ 之上。通过在空指针域中存储遍历顺序下的</strong>前驱/后继</strong>（称为“线索”），来加速遍历操作。其底层物理结构依然是二叉链表。</p><h4 id="线索二叉树-二叉链表与双链表的结合" tabindex="-1"><a class="header-anchor" href="#线索二叉树-二叉链表与双链表的结合"><span>线索二叉树--二叉链表与双链表的结合</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 线索二叉树节点结构</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ElemType data;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lchild, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">rchild;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ltag;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 0:指向孩子，1:指向前驱线索</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> rtag;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 0:指向孩子，1:指向后继线索</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} ThreadNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>中序线索化<br> 将二叉树转为孩子表示法，再中序遍历，将中序遍历结果作为线索<br> 空闲的标志位在1时，前驱表示中序遍历的前驱，后继表示为中序遍历的后继<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222143211.png" alt="image.png" loading="lazy"></p><h4 id="关于中序第一个节点的线索和最后一个节点的线索问题" tabindex="-1"><a class="header-anchor" href="#关于中序第一个节点的线索和最后一个节点的线索问题"><span>关于中序第一个节点的线索和最后一个节点的线索问题</span></a></h4><h5 id="无头节点" tabindex="-1"><a class="header-anchor" href="#无头节点"><span>无头节点</span></a></h5><p>第一个元素的左指针若空闲指向NULL，最后一个元素右指针若空闲也指向NULL</p><h5 id="有头节点" tabindex="-1"><a class="header-anchor" href="#有头节点"><span>有头节点</span></a></h5><p>头节点的左指针指向第一个元素，右指针指向最后一个元素，而第一个元素指向头节点，最后一个元素指向头节点<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222150211.png" alt="image.png" loading="lazy"></p><h2 id="最小生成树算法-无向图" tabindex="-1"><a class="header-anchor" href="#最小生成树算法-无向图"><span>最小生成树算法（无向图）</span></a></h2><p>目标：生成的树边权和一定唯一，生成树不唯一</p><h3 id="加点法-普利姆算法" tabindex="-1"><a class="header-anchor" href="#加点法-普利姆算法"><span>加点法----普利姆算法</span></a></h3><p>从任一顶点开始，每次选择连接已选顶点集和未选顶点集的最小权边，将该边及其连接的未选顶点加入生成树，直到所有顶点都被选中</p><h3 id="加边法-克鲁斯卡尔算法" tabindex="-1"><a class="header-anchor" href="#加边法-克鲁斯卡尔算法"><span>加边法----克鲁斯卡尔算法</span></a></h3><p>将所有边按权值从小到大排序，依次选择每条边，若该边连接的两个顶点不在同一连通分量中，则加入该边，否则跳过，直到选中 n-1 条边（n 为顶点数）</p><h2 id="折半查找" tabindex="-1"><a class="header-anchor" href="#折半查找"><span>折半查找</span></a></h2><p>要求：1.必须是数组（顺序表）2.数据必须是有顺序的</p><ol><li>指定left和right指针，left指向首个元素，right指向最后一个元素，表明数组的范围</li><li>mid指向数组的中间位置（（left+right）/2），将我的数字与mid指向的数据进行比较</li><li>如果数字比我的大，则缩小right到mid-1的位置.如果数字比我的小，则扩大left到m id+1的位置</li><li>重复步骤2和4，缩小到最后，出现小数点，向下取整，然后再进行比较 <ol><li>如果left大于right，就是找不到了</li></ol></li></ol><h2 id="总复习" tabindex="-1"><a class="header-anchor" href="#总复习"><span>总复习</span></a></h2><h3 id="第一优先级-重中之重-必须掌握" tabindex="-1"><a class="header-anchor" href="#第一优先级-重中之重-必须掌握"><span>第一优先级（重中之重，必须掌握）</span></a></h3><p><strong>目标：掌握这些内容，就能解决绝大部分大题和核心程序题。</strong></p><ol><li><p><strong>第八章 图</strong></p><ul><li><p><strong>最短路径</strong>：<strong>Dijkstra算法</strong>（考纲明确“必考”）。必须能逐步推演、写出过程。<br> 画一个表，选定一个点，从此点开始，寻找到每个结点的权值最小值，填入对应轮次的表格内，不可达填写∞，并在当前轮次选择一个最小权值的点，作为确定值，以后不再对此值进行改变，并作为下一轮次的初始结点，寻找到每个结点的权值最小值。</p></li><li><p><strong>图的遍历</strong>：深度优先搜索(DFS)和广度优先搜索(BFS)的序列结果。<br> 如果给邻接表，则只有唯一解，按照邻接表的顺序，进行深度、广度遍历，最后输出序列结果</p></li><li><p><strong>最小生成树</strong>：Prim算法和Kruskal算法的步骤、区别及应用场景。<br> 我了解了Prim算法和Kruskal算法，不了解区别以及应用场景具体如下：<br> Prim先选中图中任意结点，然后再查找最近路径且通向未选中过的结点，选中后继续查找最近路径且通向未选中过的结点，以此类推，直到选中所有点<br> Kruskal算法先只关注所有点，在点之间选择权值最小的路径，且这个路径不在一个连通集合内，直到连接所有的点，没有未连接的连通变量</p></li></ul></li><li><p><strong>第七章 树</strong></p><ul><li><p><strong>二叉树遍历</strong>：给定一棵树，能写出<strong>先序、中序、后序</strong>遍历序列（大题基础）。<br> 先序先访问当前，然后递归访问左子树，右子树<br> 中序先递归访问左子树，然后访问当前，递归访问右子树<br> 后序先递归访问左子树，递归访问右子树，最后访问当前结点</p></li><li><p><strong>哈夫曼树与编码</strong>：能根据一组权值<strong>画出哈夫曼树</strong>，并写出对应的<strong>哈夫曼编码</strong>。<br> 先将一组权值对应的数据从小到大排序，选出两个最小权值，相加获得其父的权值大小，然后划去已经构造进树的权值，将其相加获得的权值做个标记，加入到升序的权值表中，然后再进行之前的步骤，如果在权值升序列表中遇到构造出来的父节点（做标记过的权值），则将其顺序下一个元素与其构成兄弟，算出父节点的权值，继续添加到权值升序表内，知道所有的权值元素都已经构造进树内，这就是一颗哈夫曼树<br> 在哈夫曼树的根节点向下遍历访问，左子树为编码0，右子树为编码1</p></li></ul></li><li><p><strong>第九章 查找</strong></p><ul><li><strong>二叉排序树</strong>：给定一个序列，能画出二叉排序树的构造过程，以及<strong>插入、删除</strong>结点的操作。<br> 将序列中的任意结点作为根节点，选择第一个元素，如果比根节点小则想左构造子树，反之向右，对于目标结点的构造需要对根节点左右两颗子树进行递归比较<br> 实现插入，则将此数值用二叉排序树进行递归比较构造即可<br> 实现删除，如果删除的结点只有左子树或者右子树，则之间删除这个结点，让其子树代替他即可，如果选择删除的点有左右两个子树，那么</li></ul></li></ol><h3 id="🥈-第二优先级-重要得分点-需熟练" tabindex="-1"><a class="header-anchor" href="#🥈-第二优先级-重要得分点-需熟练"><span>🥈 第二优先级（重要得分点，需熟练）</span></a></h3><p><strong>目标：这些是程序大题和重要概念的核心，需理解透彻。</strong></p><ol><li><p><strong>第九章 查找 &amp; 第十章 排序</strong></p><ul><li><strong>程序填空题/选择题</strong>：重点理解<strong>折半查找、直接插入排序、折半插入排序</strong>的<strong>算法逻辑、代码流程和边界条件</strong>。动手模拟代码执行。</li></ul></li><li><p><strong>第七章 树 &amp; 第九章 查找</strong></p><ul><li><p><strong>线索二叉树</strong>：理解线索化的目的，能进行线索化。</p></li><li><p><strong>哈希表</strong>：掌握<strong>处理哈希冲突</strong>的几种主要方法（如开放定址法、链地址法）。</p></li></ul></li></ol><h3 id="🥉-第三优先级-基础保障-需熟记" tabindex="-1"><a class="header-anchor" href="#🥉-第三优先级-基础保障-需熟记"><span>🥉 第三优先级（基础保障，需熟记）</span></a></h3><p><strong>目标：确保小题和概念题不丢分。</strong></p><ol><li><p><strong>第一章 绪论</strong>：数据结构的基本概念、术语定义。</p></li><li><p><strong>第二章 线性表</strong>：顺序表和链表（单链表）的<strong>基本操作、特点、区别</strong>。</p></li><li><p><strong>第三章 栈和队列</strong>：栈（FILO）和队列（FIFO）的<strong>特性、基本操作</strong>。</p></li><li><p><strong>第八章 图</strong>：</p><ul><li><p><strong>图的存储结构</strong>（邻接矩阵、邻接表）。</p></li><li><p><strong>AOE网</strong>的相关概念（如关键路径）。</p></li></ul></li></ol>`,74)]))}const d=i(l,[["render",e],["__file","数据结构.html.vue"]]),g=JSON.parse('{"path":"/article/04_%E5%BD%92%E6%A1%A3/%E8%80%83%E8%AF%95%E5%91%A8%E7%A0%B4%E9%98%B2/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"数据结构","lang":"zh-CN","frontmatter":{"tags":null,"icon":"pen-to-square","date":"2025-12-22T00:00:00.000Z","title":"数据结构","category":["归档"],"description":"考纲 题型分类 章节 核心考点/题型说明 **大题 (重点)**​ 第七章 树​ 二叉树遍历（先/中/后序） 线索二叉树 哈夫曼树与编码（画树、写编码） 树的性质计算 第八章 图​ 图的遍历（深度优先DFS、广度优先BFS） 最小生成树（Prim算法, Kruskal算法） 最短路径（Dijkstra算法，必考） 图的存储结构 第九章 查找​ 二叉排序...","head":[["meta",{"property":"og:url","content":"https://github.com/fakeppa/fakeppa.github.io/article/04_%E5%BD%92%E6%A1%A3/%E8%80%83%E8%AF%95%E5%91%A8%E7%A0%B4%E9%98%B2/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"问己"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:description","content":"考纲 题型分类 章节 核心考点/题型说明 **大题 (重点)**​ 第七章 树​ 二叉树遍历（先/中/后序） 线索二叉树 哈夫曼树与编码（画树、写编码） 树的性质计算 第八章 图​ 图的遍历（深度优先DFS、广度优先BFS） 最小生成树（Prim算法, Kruskal算法） 最短路径（Dijkstra算法，必考） 图的存储结构 第九章 查找​ 二叉排序..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-24T09:20:53.000Z"}],["meta",{"property":"article:published_time","content":"2025-12-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-24T09:20:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251224004636.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222143211.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222150211.png\\"],\\"datePublished\\":\\"2025-12-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-24T09:20:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"fakeppa\\",\\"url\\":\\"https://github.com/fakeppa/fakeppa.github.io\\"}]}"]]},"headers":[{"level":2,"title":"考纲","slug":"考纲","link":"#考纲","children":[]},{"level":2,"title":"树结构的线性存储","slug":"树结构的线性存储","link":"#树结构的线性存储","children":[{"level":3,"title":"1. 顺序存储法(二叉树逻辑较简单)","slug":"_1-顺序存储法-二叉树逻辑较简单","link":"#_1-顺序存储法-二叉树逻辑较简单","children":[]}]},{"level":2,"title":"2. 链式存储法（主流方法）","slug":"_2-链式存储法-主流方法","link":"#_2-链式存储法-主流方法","children":[]},{"level":2,"title":"方法三：其他与高级方法","slug":"方法三-其他与高级方法","link":"#方法三-其他与高级方法","children":[]},{"level":2,"title":"最小生成树算法（无向图）","slug":"最小生成树算法-无向图","link":"#最小生成树算法-无向图","children":[{"level":3,"title":"加点法----普利姆算法","slug":"加点法-普利姆算法","link":"#加点法-普利姆算法","children":[]},{"level":3,"title":"加边法----克鲁斯卡尔算法","slug":"加边法-克鲁斯卡尔算法","link":"#加边法-克鲁斯卡尔算法","children":[]}]},{"level":2,"title":"折半查找","slug":"折半查找","link":"#折半查找","children":[]},{"level":2,"title":"总复习","slug":"总复习","link":"#总复习","children":[{"level":3,"title":"第一优先级（重中之重，必须掌握）","slug":"第一优先级-重中之重-必须掌握","link":"#第一优先级-重中之重-必须掌握","children":[]},{"level":3,"title":"🥈 第二优先级（重要得分点，需熟练）","slug":"🥈-第二优先级-重要得分点-需熟练","link":"#🥈-第二优先级-重要得分点-需熟练","children":[]},{"level":3,"title":"🥉 第三优先级（基础保障，需熟记）","slug":"🥉-第三优先级-基础保障-需熟记","link":"#🥉-第三优先级-基础保障-需熟记","children":[]}]}],"git":{"createdTime":1766383909000,"updatedTime":1766568053000,"contributors":[{"name":"fakeppa","username":"fakeppa","email":"l17091799155@qq.com","commits":28,"url":"https://github.com/fakeppa"}]},"readingTime":{"minutes":8.55,"words":2565},"filePathRelative":"article/04_归档/考试周破防/大二上/数据结构.md","localizedDate":"2025年12月22日","excerpt":"<h2>考纲</h2>\\n<p>题型分类</p>\\n<p>章节</p>\\n<p>核心考点/题型说明</p>\\n<p>**大题 (重点)**​</p>\\n<p><strong>第七章 树</strong>​</p>\\n<ol>\\n<li><strong>二叉树遍历</strong>（先/中/后序）</li>\\n<li><strong>线索二叉树</strong></li>\\n<li><strong>哈夫曼树与编码</strong>（画树、写编码）</li>\\n<li>树的性质计算</li>\\n</ol>\\n<p><strong>第八章 图</strong>​</p>\\n<ol>\\n<li><strong>图的遍历</strong>（深度优先DFS、广度优先BFS）</li>\\n<li><strong>最小生成树</strong>（Prim算法, Kruskal算法）</li>\\n<li><strong>最短路径</strong>（<strong>Dijkstra算法，必考</strong>）</li>\\n<li>图的存储结构</li>\\n</ol>","autoDesc":true}');export{d as comp,g as data};
