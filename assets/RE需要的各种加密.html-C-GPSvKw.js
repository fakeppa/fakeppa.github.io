import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,b as o,o as r}from"./app-E_u2bPAe.js";const s={};function l(a,t){return r(),e("div",null,t[0]||(t[0]=[o('<h2 id="tea算法" tabindex="-1"><a class="header-anchor" href="#tea算法"><span>TEA算法</span></a></h2><h3 id="如何理解tea算法" tabindex="-1"><a class="header-anchor" href="#如何理解tea算法"><span>如何理解TEA算法</span></a></h3><p>想象你要加密一段秘密信息，TEA会把它切成一个个​<strong>​8字节的小块​</strong>​（比如像切豆腐块）。每次只处理一块。</p><ol><li><p><strong>准备工作​</strong>​：先把这8字节切成左右两半，叫​<strong>​左变量​</strong>​和​<strong>​右变量​</strong>​。同时准备好你的​<strong>​128位密钥​</strong>​（16字节），它也切成4小份。</p></li><li><p>​<strong>​开始搅拌（32轮）​</strong>​：每一轮的操作都非常相似，就像和面一样：</p><ul><li><p>先加一勺固定的“魔法调料水”（这个水叫 ​<strong>​delta​</strong>​，值是 <code>0x9E3779B9</code>）。每一轮都加一勺，所以调料水越加越多。</p></li><li><p>然后，用​<strong>​右变量​</strong>​（右边那半）来炒​<strong>​左变量​</strong>​：把右变量做一些移位操作（左移4位，右移5位），和当前的“调料水”以及密钥的第1、2份混合在一起，做复杂的异或和加法。把这个炒出来的结果，“浇”到左变量上，让左变量彻底变样。</p></li><li><p>紧接着，用这个​<strong>​刚更新完的左变量​</strong>​，以完全同样的方式去炒​<strong>​右变量​</strong>​，并把它“浇”到右变量上。</p></li><li><p>这样，左右变量就互相“污染”了对方一次。</p></li></ul></li><li><p>​<strong>​循环往复​</strong>​：这个互相“炒菜”的过程​<strong>​重复整整32轮​</strong>​。每一轮都让左右变量混合得更彻底，直到原始信息面目全非。</p></li><li><p>​<strong>​出锅​</strong>​：32轮结束后，最终被彻底“炒熟”的左变量和右变量拼在一起，就形成了最终的​<strong>​8字节密文​</strong>​</p></li></ol><p>如果信息很长，有很多个8字节块，那就​<strong>​对每一块都重复一遍​</strong>​这个“切块-&gt;搅拌32轮-&gt;出锅”的过程。</p><p>​<strong>​总结一下​</strong>​：TEA加密就是一个基于​<strong>​Feistel结构​</strong>​的、通过​<strong>​多轮次​</strong>​的简单操作（加、移位、异或）进行​<strong>​充分混合​</strong>​，最终达到加密效果的过程。它的​<strong>​核心特征​</strong>​就是那32轮循环以及每轮中都会出现的​<strong>​固定常量delta (<code>0x9E3779B9</code>)​</strong>​。</p><p>加密一个块时，核心是进行 ​<strong>​32轮的“搅拌”操作​</strong>​。</p><h3 id="一、核心计算要素" tabindex="-1"><a class="header-anchor" href="#一、核心计算要素"><span>一、核心计算要素</span></a></h3><h4 id="_1-输入参数" tabindex="-1"><a class="header-anchor" href="#_1-输入参数"><span>1. 输入参数</span></a></h4><ul><li><p>​<strong>​明文数据​</strong>​：64位（8字节）数据块</p><ul><li><p>分为两个32位字：<code>v0</code>和 <code>v1</code></p></li><li><p>示例：<code>unsigned long EntryData[2] = {v0, v1};</code></p></li></ul></li><li><p>​<strong>​密钥​</strong>​：128位（16字节）密钥</p><ul><li><p>分为四个32位字：<code>k0, k1, k2, k3</code></p></li><li><p>示例：<code>unsigned long Key[4] = {k0, k1, k2, k3};</code></p></li></ul></li><li><p>​<strong>​轮数​</strong>​：固定32轮（标准实现）</p></li></ul><h4 id="_2-输出结果" tabindex="-1"><a class="header-anchor" href="#_2-输出结果"><span>2. 输出结果</span></a></h4><ul><li><p>​<strong>​密文数据​</strong>​：64位加密结果</p><ul><li><p>同样存储为两个32位字：<code>v0&#39;</code>和 <code>v1&#39;</code></p></li><li><p>示例：<code>EntryData[0] = v0&#39;, EntryData[1] = v1&#39;</code></p></li></ul></li></ul><h4 id="_3-核心常量" tabindex="-1"><a class="header-anchor" href="#_3-核心常量"><span>3. 核心常量</span></a></h4><ul><li><p>​<strong>​Delta (δ)​</strong>​：<code>0x9E3779B9</code></p><ul><li><p>黄金分割常数（2³²/φ，φ≈1.618）</p></li><li><p>数学意义：<code>⌊2³² × (√5-1)/2⌋</code></p></li></ul></li></ul>',14)]))}const g=n(s,[["render",l],["__file","RE需要的各种加密.html.vue"]]),c=JSON.parse('{"path":"/article/03_%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90__%E9%80%86%E5%90%91%E7%BB%8F%E9%AA%8C%E5%8C%85/RE%E9%9C%80%E8%A6%81%E7%9A%84%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86.html","title":"RE需要的各种加密","lang":"zh-CN","frontmatter":{"aliases":null,"tags":null,"cssclasses":null,"icon":"pen-to-square","date":"2025-09-18T00:00:00.000Z","title":"RE需要的各种加密","category":["项目"],"description":"TEA算法 如何理解TEA算法 想象你要加密一段秘密信息，TEA会把它切成一个个​​8字节的小块​​（比如像切豆腐块）。每次只处理一块。 准备工作​​：先把这8字节切成左右两半，叫​​左变量​​和​​右变量​​。同时准备好你的​​128位密钥​​（16字节），它也切成4小份。 ​​开始搅拌（32轮）​​：每一轮的操作都非常相似，就像和面一样： 先加一勺...","head":[["meta",{"property":"og:url","content":"https://github.com/fakeppa/fakeppa.github.io/article/03_%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90__%E9%80%86%E5%90%91%E7%BB%8F%E9%AA%8C%E5%8C%85/RE%E9%9C%80%E8%A6%81%E7%9A%84%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86.html"}],["meta",{"property":"og:site_name","content":"问己"}],["meta",{"property":"og:title","content":"RE需要的各种加密"}],["meta",{"property":"og:description","content":"TEA算法 如何理解TEA算法 想象你要加密一段秘密信息，TEA会把它切成一个个​​8字节的小块​​（比如像切豆腐块）。每次只处理一块。 准备工作​​：先把这8字节切成左右两半，叫​​左变量​​和​​右变量​​。同时准备好你的​​128位密钥​​（16字节），它也切成4小份。 ​​开始搅拌（32轮）​​：每一轮的操作都非常相似，就像和面一样： 先加一勺..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-19T15:31:50.000Z"}],["meta",{"property":"article:published_time","content":"2025-09-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-19T15:31:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RE需要的各种加密\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-09-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-19T15:31:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"fakeppa\\",\\"url\\":\\"https://github.com/fakeppa/fakeppa.github.io\\"}]}"]]},"headers":[{"level":2,"title":"TEA算法","slug":"tea算法","link":"#tea算法","children":[{"level":3,"title":"如何理解TEA算法","slug":"如何理解tea算法","link":"#如何理解tea算法","children":[]},{"level":3,"title":"一、核心计算要素","slug":"一、核心计算要素","link":"#一、核心计算要素","children":[]}]}],"git":{"createdTime":1762845999000,"updatedTime":1763566310000,"contributors":[{"name":"fakeppa","username":"fakeppa","email":"l17091799155@qq.com","commits":25,"url":"https://github.com/fakeppa"}]},"readingTime":{"minutes":2.27,"words":680},"filePathRelative":"article/03_资源/资源__逆向经验包/RE需要的各种加密.md","localizedDate":"2025年9月18日","excerpt":"<h2>TEA算法</h2>\\n<h3>如何理解TEA算法</h3>\\n<p>想象你要加密一段秘密信息，TEA会把它切成一个个​<strong>​8字节的小块​</strong>​（比如像切豆腐块）。每次只处理一块。</p>\\n<ol>\\n<li>\\n<p><strong>准备工作​</strong>​：先把这8字节切成左右两半，叫​<strong>​左变量​</strong>​和​<strong>​右变量​</strong>​。同时准备好你的​<strong>​128位密钥​</strong>​（16字节），它也切成4小份。</p>\\n</li>\\n<li>\\n<p>​<strong>​开始搅拌（32轮）​</strong>​：每一轮的操作都非常相似，就像和面一样：</p>\\n<ul>\\n<li>\\n<p>先加一勺固定的“魔法调料水”（这个水叫 ​<strong>​delta​</strong>​，值是&nbsp;<code>0x9E3779B9</code>）。每一轮都加一勺，所以调料水越加越多。</p>\\n</li>\\n<li>\\n<p>然后，用​<strong>​右变量​</strong>​（右边那半）来炒​<strong>​左变量​</strong>​：把右变量做一些移位操作（左移4位，右移5位），和当前的“调料水”以及密钥的第1、2份混合在一起，做复杂的异或和加法。把这个炒出来的结果，“浇”到左变量上，让左变量彻底变样。</p>\\n</li>\\n<li>\\n<p>紧接着，用这个​<strong>​刚更新完的左变量​</strong>​，以完全同样的方式去炒​<strong>​右变量​</strong>​，并把它“浇”到右变量上。</p>\\n</li>\\n<li>\\n<p>这样，左右变量就互相“污染”了对方一次。</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>​<strong>​循环往复​</strong>​：这个互相“炒菜”的过程​<strong>​重复整整32轮​</strong>​。每一轮都让左右变量混合得更彻底，直到原始信息面目全非。</p>\\n</li>\\n<li>\\n<p>​<strong>​出锅​</strong>​：32轮结束后，最终被彻底“炒熟”的左变量和右变量拼在一起，就形成了最终的​<strong>​8字节密文​</strong>​</p>\\n</li>\\n</ol>","autoDesc":true}');export{g as comp,c as data};
