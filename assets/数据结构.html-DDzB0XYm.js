import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as n,o as e}from"./app-CIqtxGWw.js";const a={};function l(r,t){return e(),s("div",null,t[0]||(t[0]=[n(`<h2 id="考纲" tabindex="-1"><a class="header-anchor" href="#考纲"><span>考纲</span></a></h2><p>题型分类</p><p>章节</p><p>核心考点/题型说明</p><p>**大题 (重点)**​</p><p><strong>第七章 树</strong>​</p><ol><li><strong>二叉树遍历</strong>（先/中/后序）</li><li><strong>线索二叉树</strong></li><li><strong>哈夫曼树与编码</strong>（画树、写编码）</li><li>树的性质计算</li></ol><p><strong>第八章 图</strong>​</p><ol><li><strong>图的遍历</strong>（深度优先DFS、广度优先BFS）</li><li><strong>最小生成树</strong>（Prim算法, Kruskal算法）</li><li><strong>最短路径</strong>（<strong>Dijkstra算法，必考</strong>）</li><li>图的存储结构</li></ol><p><strong>第九章 查找</strong>​</p><ol><li><strong>二叉排序树</strong>（构建、插入、删除等）</li><li>平衡二叉树（了解概念）</li><li>哈希表（冲突处理）</li></ol><p>**程序题 (代码)**​</p><p><strong>第九章 查找</strong>​</p><p><strong>程序填空/选择大题</strong>：</p><ul><li>顺序查找</li><li>折半查找</li></ul><p><strong>第十章 排序</strong>​</p><p><strong>程序填空/选择大题</strong>：</p><ul><li>直接插入排序</li><li>折半插入排序</li></ul><p>**小题 (概念/基础)**​</p><p><strong>第一章 绪论</strong>​</p><p>选择题：基本概念、定义</p><p><strong>第二章 线性表</strong>​</p><p>小题：顺序表、单链表、链表、线性表的相关基础操作与概念</p><p><strong>第三章 栈和队列</strong>​</p><p>小题：栈与队列的基本特性、操作</p><p><strong>第八章 图</strong>​</p><p>小题：AOE网的相关概<br> 念</p><h2 id="树结构的线性存储" tabindex="-1"><a class="header-anchor" href="#树结构的线性存储"><span>树结构的线性存储</span></a></h2><h3 id="_1-顺序存储法-二叉树逻辑较简单" tabindex="-1"><a class="header-anchor" href="#_1-顺序存储法-二叉树逻辑较简单"><span>1. 顺序存储法(二叉树逻辑较简单)</span></a></h3><p><strong>根据二叉树的顺序存储规则，根节点存储在索引1（或0），对于任意节点 i，其左子节点存储在 2i 处，右子节点存储在 2i+1 处（若从0开始索引，则左子节点为 2i+1，右子节点为 2i+2）。空缺位置用0表示。</strong></p><h2 id="_2-链式存储法-主流方法" tabindex="-1"><a class="header-anchor" href="#_2-链式存储法-主流方法"><span>2. 链式存储法（主流方法）</span></a></h2><p><strong>存储表</strong>（数组实现）</p><table><thead><tr><th>索引</th><th>数据</th><th>父节点索引</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>-1</td></tr><tr><td>1</td><td>B</td><td>0</td></tr><tr><td>2</td><td>C</td><td>0</td></tr><tr><td>3</td><td>D</td><td>0</td></tr><tr><td>4</td><td>E</td><td>1</td></tr><tr><td>5</td><td>F</td><td>2</td></tr><tr><td>6</td><td>H</td><td>3</td></tr><tr><td><strong>优点</strong>：找父亲、找根极快。</td><td></td><td></td></tr><tr><td><strong>缺点</strong>：找所有孩子极慢（需遍历整个表）。</td><td></td><td></td></tr></tbody></table><p>写做：<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png" alt="image.png" loading="lazy"></p><p><strong>2. 孩子表示法</strong><br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251224004636.png" alt="image.png" loading="lazy"><br> 每个节点记录“所有孩子是谁”。<br><strong>节点数组</strong>（顺序表）：</p><table><thead><tr><th>索引</th><th>数据</th><th>第一个孩子指针</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>→ [1] → [2] → [3] → NULL</td></tr><tr><td>1</td><td>B</td><td>→ [4] → NULL</td></tr><tr><td>2</td><td>C</td><td>→ [5] → NULL</td></tr><tr><td>3</td><td>D</td><td>→ [6] → NULL</td></tr><tr><td>4</td><td>E</td><td>NULL</td></tr><tr><td>5</td><td>F</td><td>NULL</td></tr><tr><td>6</td><td>H</td><td>NULL</td></tr></tbody></table><p><strong>3. 孩子兄弟表示法（最常用、最重要）</strong></p><p>这是<strong>将任意树转换为二叉树</strong>的标准方法。每个节点包含</p><ul><li><code>数据</code></li><li><code>firstChild</code>：指向<strong>第一个孩子</strong></li><li><code>nextSibling</code>：指向<strong>下一个兄弟</strong></li></ul><p>写做<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png" alt="image.png" loading="lazy"></p><h2 id="方法三-其他与高级方法" tabindex="-1"><a class="header-anchor" href="#方法三-其他与高级方法"><span>方法三：其他与高级方法</span></a></h2><p><strong>1. 边表表示法（适用于以边为核心的操作）</strong></p><p>存储所有边（如<code>(A,B)</code>, <code>(A,C)</code>, <code>(A,D)</code>, <code>(B,E)</code>, <code>(C,F)</code>, <code>(D,H)</code>），再配合节点表。在图论中更常见。</p><p><strong>2. 邻接表（图的通用表示，树是特殊的图）</strong></p><p>与“孩子表示法”类似，是图的标准存储方式之一，每个节点维护一个邻居（孩子）链表。</p><p><strong>3. 线索二叉树（您之前问到的——这是方法的“优化”，而非独立方法）</strong></p><p>它建立在<strong>孩子兄弟表示法（二叉链表）<strong>​ 之上。通过在空指针域中存储遍历顺序下的</strong>前驱/后继</strong>（称为“线索”），来加速遍历操作。其底层物理结构依然是二叉链表。</p><h4 id="线索二叉树-二叉链表与双链表的结合" tabindex="-1"><a class="header-anchor" href="#线索二叉树-二叉链表与双链表的结合"><span>线索二叉树--二叉链表与双链表的结合</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 线索二叉树节点结构</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ElemType data;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lchild, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">rchild;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ltag;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 0:指向孩子，1:指向前驱线索</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> rtag;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 0:指向孩子，1:指向后继线索</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} ThreadNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>中序线索化<br> 将二叉树转为孩子表示法，再中序遍历，将中序遍历结果作为线索<br> 空闲的标志位在1时，前驱表示中序遍历的前驱，后继表示为中序遍历的后继<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222143211.png" alt="image.png" loading="lazy"></p><h4 id="关于中序第一个节点的线索和最后一个节点的线索问题" tabindex="-1"><a class="header-anchor" href="#关于中序第一个节点的线索和最后一个节点的线索问题"><span>关于中序第一个节点的线索和最后一个节点的线索问题</span></a></h4><h5 id="无头节点" tabindex="-1"><a class="header-anchor" href="#无头节点"><span>无头节点</span></a></h5><p>第一个元素的左指针若空闲指向NULL，最后一个元素右指针若空闲也指向NULL</p><h5 id="有头节点" tabindex="-1"><a class="header-anchor" href="#有头节点"><span>有头节点</span></a></h5><p>头节点的左指针指向第一个元素，右指针指向最后一个元素，而第一个元素指向头节点，最后一个元素指向头节点<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222150211.png" alt="image.png" loading="lazy"></p><h2 id="最小生成树算法-无向图" tabindex="-1"><a class="header-anchor" href="#最小生成树算法-无向图"><span>最小生成树算法（无向图）</span></a></h2><p>目标：生成的树边权和一定唯一，生成树不唯一</p><h3 id="加点法-普利姆算法" tabindex="-1"><a class="header-anchor" href="#加点法-普利姆算法"><span>加点法----普利姆算法</span></a></h3><p>从任一顶点开始，每次选择连接已选顶点集和未选顶点集的最小权边，将该边及其连接的未选顶点加入生成树，直到所有顶点都被选中</p><h3 id="加边法-克鲁斯卡尔算法" tabindex="-1"><a class="header-anchor" href="#加边法-克鲁斯卡尔算法"><span>加边法----克鲁斯卡尔算法</span></a></h3><p>将所有边按权值从小到大排序，依次选择每条边，若该边连接的两个顶点不在同一连通分量中，则加入该边，否则跳过，直到选中 n-1 条边（n 为顶点数）</p><h2 id="折半查找" tabindex="-1"><a class="header-anchor" href="#折半查找"><span>折半查找</span></a></h2><p>要求：1.必须是数组（顺序表）2.数据必须是有顺序的</p><ol><li>指定left和right指针，left指向首个元素，right指向最后一个元素，表明数组的范围</li><li>mid指向数组的中间位置（（left+right）/2），将我的数字与mid指向的数据进行比较</li><li>如果数字比我的大，则缩小right到mid-1的位置.如果数字比我的小，则扩大left到m id+1的位置</li><li>重复步骤2和4，缩小到最后，出现小数点，向下取整，然后再进行比较 <ol><li>如果left大于right，就是找不到了</li></ol></li></ol>`,64)]))}const o=i(a,[["render",l],["__file","数据结构.html.vue"]]),h=JSON.parse('{"path":"/article/04_%E5%BD%92%E6%A1%A3/%E8%80%83%E8%AF%95%E5%91%A8%E7%A0%B4%E9%98%B2/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"数据结构","lang":"zh-CN","frontmatter":{"tags":null,"icon":"pen-to-square","date":"2025-12-22T00:00:00.000Z","title":"数据结构","category":["归档"],"description":"考纲 题型分类 章节 核心考点/题型说明 **大题 (重点)**​ 第七章 树​ 二叉树遍历（先/中/后序） 线索二叉树 哈夫曼树与编码（画树、写编码） 树的性质计算 第八章 图​ 图的遍历（深度优先DFS、广度优先BFS） 最小生成树（Prim算法, Kruskal算法） 最短路径（Dijkstra算法，必考） 图的存储结构 第九章 查找​ 二叉排序...","head":[["meta",{"property":"og:url","content":"https://github.com/fakeppa/fakeppa.github.io/article/04_%E5%BD%92%E6%A1%A3/%E8%80%83%E8%AF%95%E5%91%A8%E7%A0%B4%E9%98%B2/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"问己"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:description","content":"考纲 题型分类 章节 核心考点/题型说明 **大题 (重点)**​ 第七章 树​ 二叉树遍历（先/中/后序） 线索二叉树 哈夫曼树与编码（画树、写编码） 树的性质计算 第八章 图​ 图的遍历（深度优先DFS、广度优先BFS） 最小生成树（Prim算法, Kruskal算法） 最短路径（Dijkstra算法，必考） 图的存储结构 第九章 查找​ 二叉排序..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-24T08:26:38.000Z"}],["meta",{"property":"article:published_time","content":"2025-12-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-24T08:26:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251224004636.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222143211.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222150211.png\\"],\\"datePublished\\":\\"2025-12-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-24T08:26:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"fakeppa\\",\\"url\\":\\"https://github.com/fakeppa/fakeppa.github.io\\"}]}"]]},"headers":[{"level":2,"title":"考纲","slug":"考纲","link":"#考纲","children":[]},{"level":2,"title":"树结构的线性存储","slug":"树结构的线性存储","link":"#树结构的线性存储","children":[{"level":3,"title":"1. 顺序存储法(二叉树逻辑较简单)","slug":"_1-顺序存储法-二叉树逻辑较简单","link":"#_1-顺序存储法-二叉树逻辑较简单","children":[]}]},{"level":2,"title":"2. 链式存储法（主流方法）","slug":"_2-链式存储法-主流方法","link":"#_2-链式存储法-主流方法","children":[]},{"level":2,"title":"方法三：其他与高级方法","slug":"方法三-其他与高级方法","link":"#方法三-其他与高级方法","children":[]},{"level":2,"title":"最小生成树算法（无向图）","slug":"最小生成树算法-无向图","link":"#最小生成树算法-无向图","children":[{"level":3,"title":"加点法----普利姆算法","slug":"加点法-普利姆算法","link":"#加点法-普利姆算法","children":[]},{"level":3,"title":"加边法----克鲁斯卡尔算法","slug":"加边法-克鲁斯卡尔算法","link":"#加边法-克鲁斯卡尔算法","children":[]}]},{"level":2,"title":"折半查找","slug":"折半查找","link":"#折半查找","children":[]}],"git":{"createdTime":1766383909000,"updatedTime":1766564798000,"contributors":[{"name":"fakeppa","username":"fakeppa","email":"l17091799155@qq.com","commits":24,"url":"https://github.com/fakeppa"}]},"readingTime":{"minutes":4.61,"words":1382},"filePathRelative":"article/04_归档/考试周破防/大二上/数据结构.md","localizedDate":"2025年12月22日","excerpt":"<h2>考纲</h2>\\n<p>题型分类</p>\\n<p>章节</p>\\n<p>核心考点/题型说明</p>\\n<p>**大题 (重点)**​</p>\\n<p><strong>第七章 树</strong>​</p>\\n<ol>\\n<li><strong>二叉树遍历</strong>（先/中/后序）</li>\\n<li><strong>线索二叉树</strong></li>\\n<li><strong>哈夫曼树与编码</strong>（画树、写编码）</li>\\n<li>树的性质计算</li>\\n</ol>\\n<p><strong>第八章 图</strong>​</p>\\n<ol>\\n<li><strong>图的遍历</strong>（深度优先DFS、广度优先BFS）</li>\\n<li><strong>最小生成树</strong>（Prim算法, Kruskal算法）</li>\\n<li><strong>最短路径</strong>（<strong>Dijkstra算法，必考</strong>）</li>\\n<li>图的存储结构</li>\\n</ol>","autoDesc":true}');export{o as comp,h as data};
