import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,o as i}from"./app-DDBh5AZT.js";const l={};function p(t,s){return i(),a("div",null,s[0]||(s[0]=[e(`<p>9,593 users solved</p><h4 id="description" tabindex="-1"><a class="header-anchor" href="#description"><span>Description</span></a></h4><p>What integer does this program print with arguments <code>266134863</code> and <code>1592237099</code>? File: <a href="https://mercury.picoctf.net/static/104d6022bcea93f53083aeb61b134e8b/chall.S" target="_blank" rel="noopener noreferrer">chall.S</a> Flag format: picoCTF{XXXXXXXX} -&gt; (hex, lowercase, no 0x, and 32 bits. ex. 5614267 would be picoCTF{0055aabb})</p><h4 id="hints" tabindex="-1"><a class="header-anchor" href="#hints"><span>Hints</span></a></h4><p>Simple compare</p><hr><h1 id="_00-前言" tabindex="-1"><a class="header-anchor" href="#_00-前言"><span>00. 前言</span></a></h1><p>没有汇编基础，现学现卖吧</p><h1 id="_01-代码审计" tabindex="-1"><a class="header-anchor" href="#_01-代码审计"><span>01. 代码审计</span></a></h1><p>静态分析，从头看起</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>	.arch armv8-a</span></span>
<span class="line"><span>	.file	&quot;chall.c&quot;</span></span>
<span class="line"><span>	.text</span></span>
<span class="line"><span>	.align	2</span></span>
<span class="line"><span>	.global	func1</span></span>
<span class="line"><span>	.type	func1, %function</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>.arch : armv8-a：指定了目标架构为ARMv8-A，是一个ARM架构的64位版本</li><li>.file &quot;chall.c&quot;:这是一个伪指令，用于告诉汇编器这个汇编代码是从哪个C文件转换过来的，通常用于调试信息</li><li>.text：指示接下来的代码是程序的文本段，也就是可执行代码</li><li>.align 2 ：对齐指令，确保func1函数的地址在内存中是2的倍数，这有助于提高代码的执行效率<br> 对齐数据：在cpu位数高于内存位数的时候</li><li>.global func1声明了这是一个全局标号，意味着这个标号在其他源文件中被引用</li><li>.type func1, %function:声明了func1是一个函数</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func1:</span></span>
<span class="line"><span>	sub	sp, sp, #16</span></span>
<span class="line"><span>	str	w0, [sp, 12]</span></span>
<span class="line"><span>	str	w1, [sp, 8]</span></span>
<span class="line"><span>	ldr	w1, [sp, 12]</span></span>
<span class="line"><span>	ldr	w0, [sp, 8]</span></span>
<span class="line"><span>	cmp	w1, w0</span></span>
<span class="line"><span>	bls	.L2</span></span>
<span class="line"><span>	ldr	w0, [sp, 12]</span></span>
<span class="line"><span>	b	.L3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>sub sp, sp, #16:减少了栈指针sp的值，为局部变量或函数调用的参数和返回地址分配空间。这里分配了16字节的空间计算寄存器：sp减去16，存入结果向sp寄存器</li><li><code>str w0, [sp, 12]</code>：将w0寄存器的内容加载到栈指针偏移12的内存地址中</li><li><code>ldr w1, [sp, 12]</code>：将栈指针偏移12的内容加载到w1这个寄存器中</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.L3:</span></span>
<span class="line"><span>	add	sp, sp, 16</span></span>
<span class="line"><span>	ret</span></span>
<span class="line"><span>	.size	func1, .-func1</span></span>
<span class="line"><span>	.section	.rodata</span></span>
<span class="line"><span>	.align	3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>这是func1的结束代码段</em></p><ul><li><p>add sp, sp, 16:对sp栈指针进行相加16，释放栈空间</p></li><li><p>ret：指示函数的返回，ret是一个伪指令</p></li><li><p>.size func1, .-func1：告诉连接器，这个函数func1的大小</p><p>什么是连接器？<br> 汇编程序通常由多个源文件组成，每个文件编译后生成一个目标文件。链接器将这些目标文件合并，处理符号解析和地址重定位，最终生成可执行文件。<br> 具体过程：</p><ol><li>符号解析，有些文件定义的函数或变量，连接器负责解析这些符号的引用</li><li>重定位，文件在编译时可能会使用相对地址，连接器将这些地址转换为最终可执行文件中的绝对地址</li><li>合并目标文件，将多个目标文件合并成一个可执行文件或者库</li><li>生成可执行文件，连接器负责生成最终的可执行文件格式：如elf、pe等文件，确保符合操作系统的要求，可以被执行</li></ol></li><li><p>.section .rodata:指示以后的代码和数据放入.rodata段，用于存储程序中的只读数据</p></li><li><p>.align 3:之前分析过了</p></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.LC0:</span></span>
<span class="line"><span>	.string	&quot;Result: %ld\\n&quot;</span></span>
<span class="line"><span>	.text</span></span>
<span class="line"><span>	.align	2</span></span>
<span class="line"><span>	.global	main</span></span>
<span class="line"><span>	.type	main, %function</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>.string &quot;Result: %ld\\n&quot;:定义了一个字符串常量。.string是GUN汇编器(GAS)的伪指令，用于在只读数据段(.rodata)中创建了一个字符串常量。这里的字符串时“Result: %ld\\n ”,它通常用于格式化输出一个长整型(%1d)数值，并在末尾添加一个换行符。<br><em><strong>什么是汇编器，汇编器都有哪些</strong></em></p><ul><li><strong>汇编器</strong>（Assembler）是将汇编语言代码转换为机器语言代码的工具。</li><li><strong>NASM (Netwide Assembler)</strong>、<strong>MASM (Microsoft Macro Assembler)</strong>、<strong>GAS (GNU Assembler)</strong>、<strong>FASM (Flat Assembler)</strong>、<strong>TASM (Turbo Assembler)</strong>、<strong>LLVM Assembler</strong>。</li></ul></li><li><p>注意.text之后的内容为代码段</p></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>main:</span></span>
<span class="line"><span>	stp	x29, x30, [sp, -48]!</span></span>
<span class="line"><span>	add	x29, sp, 0</span></span>
<span class="line"><span>	str	x19, [sp, 16]</span></span>
<span class="line"><span>	str	w0, [x29, 44]</span></span>
<span class="line"><span>	str	x1, [x29, 32]</span></span>
<span class="line"><span>	ldr	x0, [x29, 32]</span></span>
<span class="line"><span>	add	x0, x0, 8</span></span>
<span class="line"><span>	ldr	x0, [x0]</span></span>
<span class="line"><span>	bl	atoi</span></span>
<span class="line"><span>	mov	w19, w0</span></span>
<span class="line"><span>	ldr	x0, [x29, 32]</span></span>
<span class="line"><span>	add	x0, x0, 16</span></span>
<span class="line"><span>	ldr	x0, [x0]</span></span>
<span class="line"><span>	bl	atoi</span></span>
<span class="line"><span>	mov	w1, w0</span></span>
<span class="line"><span>	mov	w0, w19</span></span>
<span class="line"><span>	bl	func1</span></span>
<span class="line"><span>	mov	w1, w0</span></span>
<span class="line"><span>	adrp	x0, .LC0</span></span>
<span class="line"><span>	add	x0, x0, :lo12:.LC0</span></span>
<span class="line"><span>	bl	printf</span></span>
<span class="line"><span>	mov	w0, 0</span></span>
<span class="line"><span>	ldr	x19, [sp, 16]</span></span>
<span class="line"><span>	ldp	x29, x30, [sp], 48</span></span>
<span class="line"><span>	ret</span></span>
<span class="line"><span>	.size	main, .-main</span></span>
<span class="line"><span>	.ident	&quot;GCC: (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span></span>
<span class="line"><span>	.section	.note.GNU-stack,&quot;&quot;,@progbits</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>main: ：这是程序的入口点</p></li><li><p><code>stp x29, x30, [sp, -48]!</code> ：将当前的帧指针x29和返回地址x30保存到栈中，更新栈指针sp，！表示在存储后更新sp的值<br><code>stp</code>：是指令操作码，表示存储一对寄存器到内存，在这里接受了x29和x30和<code>[sp,-48]</code>三个参数，表示把x29和x30的值压入栈内，栈空间为sp当前指针减去48的内存位置<br><code>[]</code>:表示这是一个内存地址操作</p></li><li><p><code>add x29, sp, 0</code>：将当前栈指针赋给x29作为帧指针</p></li><li><p><code>str x19, [sp, 16]</code>：将寄存器x19的值存储到栈中偏移量为16的位置</p></li><li><p><code>str w0, [x29, 44]</code>:将w0值存储到帧指针偏移+44的位置</p></li><li><p><code>str x1, [x29, 32]</code>：将x1的值存储到帧指针偏移+32的位置</p></li><li><p><code>ldr x0, [x29, 32]</code>：将存储在帧指针偏移32的位置的值存储到x0寄存器，根据上文可知这里存储着x1的值</p></li><li><p><code>add x0, x0, 8</code>：将x0寄存器的值加八，存入x0，也就是之前的x1的值应该是一个内存地址，在这里偏移8</p></li><li><p><code>ldr x0, [x0]</code>：将存储在x0所指向的内存位置的值赋给x0寄存器，也就是将存储在x1偏移8位置的内存的值赋给x0</p></li><li><p><code>bl atoi</code>：调用atoi函数，这个C标准库中的函数会将字段穿转为整数，而传入atoi函数的参数被提前存放在默认的寄存器x0处</p></li><li><p><code>mov w19，w0</code>：将w0寄存器的值存储在w19中，这里存储了atoi函数的返回值<br> 这段代码从栈中读取一个内存地址，增加8，然后读取改地址的值并调用atoi函数将其转换为整数，最后奖结果存储在w19中</p></li><li><p><code>ldr x0, [x29, 32]</code>：将存储在帧指针偏移32的内容存储在x0，还是之前x1的值，是一个地址</p></li><li><p><code>add x0, x0, 16</code> ：将x0的值偏移16，赋给x0，也就是x1的值偏移16</p></li><li><p><code>ldr x0, [x0]</code>:将存储在x0地址的内容赋给x0，也就是存储在x1的值偏移16地址的内容赋给x0</p></li><li><p><code>bl atoi</code>：调用atoi函数</p></li><li><p><code>mov w1, w0</code>：将上文函数的返回值存储到w1<br> 这段代码从栈中读取另一个值，增加16，调用atoi函数，并将结果存储在w1中</p></li><li><p><code>mov w0, w19</code>：将w19的值存储在w0中，也就是首次调用atoi的返回值存储在w0</p></li><li><p><code>b1 func1</code>：调用，之前定义过得func1函数。</p></li><li><p><code>mov w1, w0</code>：将w0的值赋给w1，也就是将func1的返回值覆盖之前第二次调用atoi时的返回值<br> 这段代码将w19的值移动到w0中，然后调用func1函数，最后将返回值存储在w1中</p></li><li><p><code>adrp x0, .LC0</code>：.LC0所在的地址的页面基址加载到x0寄存器中，但是这个虚拟地址是不准确的，因为它只或提供了.LC0所在的对齐到页面边界的页面基地址，还需要结合下一个伪指令告诉编译器.LC0的具体位置，也就是基地址不能回答的低12位</p></li><li><p><code>add x0, x0, :lo12:.LC0</code>：:Lo12是一个伪指令，他告诉汇编器在编译时将.LC0标签的低12位（也就是页面基地址不能给出的除了最高位的其他位），并将这个值对x0进行相加赋给x0。</p><ul><li>在arm架构的64位cpu中虚拟地址到物理地址的转换是通过页表完成的，页表会将物理内存映射到虚拟内存，类似于8086cpu中的虚拟内存到物理内存的转换，16位段地址和偏移地址合成20位的物理地址</li></ul></li><li><p><code>bl printf</code>:调用printf函数输出<br> 这段代码准备调用printf函数，首先加载字符串常亮的地址，然后调用printf进行输出。就像上文所说的，参数默认在x0寄存器中</p></li><li><p><code>mov w0, 0</code>:将0赋给w0，清理w0内的返回值</p></li><li><p><code>ldr x19, [sp, 16]</code>：将存储在s帧指针偏移16位置的内容赋值给x19寄存器</p></li><li><p><code>ldp x29, x30, [sp], 48</code>：加载栈顶的两个内容给x29和x30寄存器，然后将sp指针增加48字节<br><code>ldp</code>指令加载了之前使用<code>stp</code>指令保存的x29和x30寄存器的值，并且调整了栈指针，以便于函数可以正确地返回。</p></li></ul><p>终于审完了，到这里，将近花费了8个小时的时间，因为以前没有分析过汇编，一切都需要问，真是太难了</p><h1 id="_02-解题过程" tabindex="-1"><a class="header-anchor" href="#_02-解题过程"><span>02. 解题过程</span></a></h1><p>注意到这个代码需要输入两串字符串作比较266134863和1592237099，<br> 首先查看main：<br> 函数初始化：<br> 通过stp指令将链接寄存器x30和x29压入栈内，并更新栈指针sp向下移动48字节，为局部变量和函数调用划分空间<br> 随后设置新的帧指针，将栈指针sp的值赋给帧指针x29，这样x29指向栈顶<br> 然后将x19寄存器的值保存到站上偏移16字节的位置，以备后用</p><p>运算过程：<br> 从栈上读取两个参数，并将他们存储到栈上<br> 将第一个参数增加8字节后，读取该地址的值，（是一个字符串）并将参数传递给atoi函数，将字符串转换为整数，结果存储在w19中<br> 将第二个参数地址加16字节后，读取该地址的值，并传递给atoi函数，结果存储在w1中<br> 将之前atoi函数的结果为参数，调用printf函数，打印结果</p><p>结束：<br> 将之前保存的x19寄存器值从站上回复<br> 将之前保存的链接寄存器x30和帧指针x29从栈上恢复，一遍返回到调用这个函数的地方<br> 将w0寄存器的值设置为0，表示程序正常结束，并返回这个值</p>`,26)]))}const c=n(l,[["render",p],["__file","ARMssembly 0.html.vue"]]),o=JSON.parse('{"path":"/article/02_%E9%A2%86%E5%9F%9F/picoCTF/%E9%80%86%E5%90%91%20reverse/ARMssembly%200.html","title":"ARMssembly 0","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-12-27T00:00:00.000Z","tags":null,"title":"ARMssembly 0","category":["领域"],"description":"9,593 users solved Description What integer does this program print with arguments 266134863 and 1592237099? File: chall.S Flag format: picoCTF{XXXXXXXX} -> (hex, lowercase, no ...","head":[["meta",{"property":"og:url","content":"https://github.com/fakeppa/fakeppa.github.io/article/02_%E9%A2%86%E5%9F%9F/picoCTF/%E9%80%86%E5%90%91%20reverse/ARMssembly%200.html"}],["meta",{"property":"og:site_name","content":"问己"}],["meta",{"property":"og:title","content":"ARMssembly 0"}],["meta",{"property":"og:description","content":"9,593 users solved Description What integer does this program print with arguments 266134863 and 1592237099? File: chall.S Flag format: picoCTF{XXXXXXXX} -> (hex, lowercase, no ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-22T06:22:16.000Z"}],["meta",{"property":"article:published_time","content":"2024-12-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-22T06:22:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ARMssembly 0\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-27T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-22T06:22:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"fakeppa\\",\\"url\\":\\"https://github.com/fakeppa/fakeppa.github.io\\"}]}"]]},"headers":[],"git":{"createdTime":1735788956000,"updatedTime":1742624536000,"contributors":[{"name":"fakeppa","username":"fakeppa","email":"l17091799155@qq.com","commits":518,"url":"https://github.com/fakeppa"}]},"readingTime":{"minutes":8.46,"words":2537},"filePathRelative":"article/02_领域/picoCTF/逆向 reverse/ARMssembly 0.md","localizedDate":"2024年12月27日","excerpt":"<p>9,593&nbsp;users solved</p>\\n<h4>Description</h4>\\n<p>What integer does this program print with arguments&nbsp;<code>266134863</code>&nbsp;and&nbsp;<code>1592237099</code>? File:&nbsp;<a href=\\"https://mercury.picoctf.net/static/104d6022bcea93f53083aeb61b134e8b/chall.S\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">chall.S</a>&nbsp;Flag format: picoCTF{XXXXXXXX} -&gt; (hex, lowercase, no 0x, and 32 bits. ex. 5614267 would be picoCTF{0055aabb})</p>","autoDesc":true}');export{c as comp,o as data};
