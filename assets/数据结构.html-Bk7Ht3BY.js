import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,b as n,o as e}from"./app-Dv6CLX1z.js";const s={};function a(r,t){return e(),d("div",null,t[0]||(t[0]=[n(`<h2 id="树结构的线性存储" tabindex="-1"><a class="header-anchor" href="#树结构的线性存储"><span>树结构的线性存储</span></a></h2><h3 id="_1-顺序存储法-二叉树逻辑较简单" tabindex="-1"><a class="header-anchor" href="#_1-顺序存储法-二叉树逻辑较简单"><span>1. 顺序存储法(二叉树逻辑较简单)</span></a></h3><p><strong>根据二叉树的顺序存储规则，根节点存储在索引1（或0），对于任意节点 i，其左子节点存储在 2i 处，右子节点存储在 2i+1 处（若从0开始索引，则左子节点为 2i+1，右子节点为 2i+2）。空缺位置用0表示。</strong></p><h2 id="_2-链式存储法-主流方法" tabindex="-1"><a class="header-anchor" href="#_2-链式存储法-主流方法"><span>2. 链式存储法（主流方法）</span></a></h2><p><strong>存储表</strong>（数组实现）</p><table><thead><tr><th>索引</th><th>数据</th><th>父节点索引</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>-1</td></tr><tr><td>1</td><td>B</td><td>0</td></tr><tr><td>2</td><td>C</td><td>0</td></tr><tr><td>3</td><td>D</td><td>0</td></tr><tr><td>4</td><td>E</td><td>1</td></tr><tr><td>5</td><td>F</td><td>2</td></tr><tr><td>6</td><td>H</td><td>3</td></tr><tr><td><strong>优点</strong>：找父亲、找根极快。</td><td></td><td></td></tr></tbody></table><p><strong>缺点</strong>：找所有孩子极慢（需遍历整个表）。<br> 写做：<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png" alt="image.png" loading="lazy"></p><p><strong>2. 孩子表示法</strong></p><p>每个节点记录“所有孩子是谁”。<br><strong>节点数组</strong>（顺序表）：</p><table><thead><tr><th>索引</th><th>数据</th><th>第一个孩子指针</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>→ [1] → [2] → [3] → NULL</td></tr><tr><td>1</td><td>B</td><td>→ [4] → NULL</td></tr><tr><td>2</td><td>C</td><td>→ [5] → NULL</td></tr><tr><td>3</td><td>D</td><td>→ [6] → NULL</td></tr><tr><td>4</td><td>E</td><td>NULL</td></tr><tr><td>5</td><td>F</td><td>NULL</td></tr><tr><td>6</td><td>H</td><td>NULL</td></tr></tbody></table><p><strong>3. 孩子兄弟表示法（最常用、最重要）</strong></p><p>这是<strong>将任意树转换为二叉树</strong>的标准方法。每个节点包含</p><ul><li><code>数据</code></li><li><code>firstChild</code>：指向<strong>第一个孩子</strong></li><li><code>nextSibling</code>：指向<strong>下一个兄弟</strong></li></ul><p>写做<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png" alt="image.png" loading="lazy"></p><h2 id="方法三-其他与高级方法" tabindex="-1"><a class="header-anchor" href="#方法三-其他与高级方法"><span>方法三：其他与高级方法</span></a></h2><p><strong>1. 边表表示法（适用于以边为核心的操作）</strong></p><p>存储所有边（如<code>(A,B)</code>, <code>(A,C)</code>, <code>(A,D)</code>, <code>(B,E)</code>, <code>(C,F)</code>, <code>(D,H)</code>），再配合节点表。在图论中更常见。</p><p><strong>2. 邻接表（图的通用表示，树是特殊的图）</strong></p><p>与“孩子表示法”类似，是图的标准存储方式之一，每个节点维护一个邻居（孩子）链表。</p><p><strong>3. 线索二叉树（您之前问到的——这是方法的“优化”，而非独立方法）</strong></p><p>它建立在<strong>孩子兄弟表示法（二叉链表）<strong>​ 之上。通过在空指针域中存储遍历顺序下的</strong>前驱/后继</strong>（称为“线索”），来加速遍历操作。其底层物理结构依然是二叉链表。</p><h4 id="线索二叉树-二叉链表与双链表的结合" tabindex="-1"><a class="header-anchor" href="#线索二叉树-二叉链表与双链表的结合"><span>线索二叉树--二叉链表与双链表的结合</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 线索二叉树节点结构</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ElemType data;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lchild, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">rchild;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ltag;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 0:指向孩子，1:指向前驱线索</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> rtag;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 0:指向孩子，1:指向后继线索</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} ThreadNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>中序线索化<br> 将二叉树转为孩子表示法，再中序遍历，将中序遍历结果作为线索<br> 空闲的标志位在1时，前驱表示中序遍历的前驱，后继表示为中序遍历的后继<br><img src="https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222143211.png" alt="image.png" loading="lazy"></p>`,24)]))}const h=i(s,[["render",a],["__file","数据结构.html.vue"]]),o=JSON.parse('{"path":"/article/04_%E5%BD%92%E6%A1%A3/%E8%80%83%E8%AF%95%E5%91%A8%E7%A0%B4%E9%98%B2/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"数据结构","lang":"zh-CN","frontmatter":{"tags":null,"icon":"pen-to-square","date":"2025-12-22T00:00:00.000Z","title":"数据结构","category":["归档"],"description":"树结构的线性存储 1. 顺序存储法(二叉树逻辑较简单) 根据二叉树的顺序存储规则，根节点存储在索引1（或0），对于任意节点 i，其左子节点存储在 2i 处，右子节点存储在 2i+1 处（若从0开始索引，则左子节点为 2i+1，右子节点为 2i+2）。空缺位置用0表示。 2. 链式存储法（主流方法） 存储表（数组实现） 缺点：找所有孩子极慢（需遍历整个表...","head":[["meta",{"property":"og:url","content":"https://github.com/fakeppa/fakeppa.github.io/article/04_%E5%BD%92%E6%A1%A3/%E8%80%83%E8%AF%95%E5%91%A8%E7%A0%B4%E9%98%B2/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"问己"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:description","content":"树结构的线性存储 1. 顺序存储法(二叉树逻辑较简单) 根据二叉树的顺序存储规则，根节点存储在索引1（或0），对于任意节点 i，其左子节点存储在 2i 处，右子节点存储在 2i+1 处（若从0开始索引，则左子节点为 2i+1，右子节点为 2i+2）。空缺位置用0表示。 2. 链式存储法（主流方法） 存储表（数组实现） 缺点：找所有孩子极慢（需遍历整个表..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-22T06:35:02.000Z"}],["meta",{"property":"article:published_time","content":"2025-12-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-22T06:35:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140840.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222140811.png\\",\\"https://cdn.jsdelivr.net/gh/fakeppa/blog-img/20251222143211.png\\"],\\"datePublished\\":\\"2025-12-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-22T06:35:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"fakeppa\\",\\"url\\":\\"https://github.com/fakeppa/fakeppa.github.io\\"}]}"]]},"headers":[{"level":2,"title":"树结构的线性存储","slug":"树结构的线性存储","link":"#树结构的线性存储","children":[{"level":3,"title":"1. 顺序存储法(二叉树逻辑较简单)","slug":"_1-顺序存储法-二叉树逻辑较简单","link":"#_1-顺序存储法-二叉树逻辑较简单","children":[]}]},{"level":2,"title":"2. 链式存储法（主流方法）","slug":"_2-链式存储法-主流方法","link":"#_2-链式存储法-主流方法","children":[]},{"level":2,"title":"方法三：其他与高级方法","slug":"方法三-其他与高级方法","link":"#方法三-其他与高级方法","children":[]}],"git":{"createdTime":1766383909000,"updatedTime":1766385302000,"contributors":[{"name":"fakeppa","username":"fakeppa","email":"l17091799155@qq.com","commits":6,"url":"https://github.com/fakeppa"}]},"readingTime":{"minutes":2.17,"words":650},"filePathRelative":"article/04_归档/考试周破防/大二上/数据结构.md","localizedDate":"2025年12月22日","excerpt":"<h2>树结构的线性存储</h2>\\n<h3>1. 顺序存储法(二叉树逻辑较简单)</h3>\\n<p><strong>根据二叉树的顺序存储规则，根节点存储在索引1（或0），对于任意节点 i，其左子节点存储在 2i 处，右子节点存储在 2i+1 处（若从0开始索引，则左子节点为 2i+1，右子节点为 2i+2）。空缺位置用0表示。</strong></p>\\n<h2>2. 链式存储法（主流方法）</h2>\\n<p><strong>存储表</strong>（数组实现）</p>\\n<table>\\n<thead>\\n<tr>\\n<th>索引</th>\\n<th>数据</th>\\n<th>父节点索引</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>0</td>\\n<td>A</td>\\n<td>-1</td>\\n</tr>\\n<tr>\\n<td>1</td>\\n<td>B</td>\\n<td>0</td>\\n</tr>\\n<tr>\\n<td>2</td>\\n<td>C</td>\\n<td>0</td>\\n</tr>\\n<tr>\\n<td>3</td>\\n<td>D</td>\\n<td>0</td>\\n</tr>\\n<tr>\\n<td>4</td>\\n<td>E</td>\\n<td>1</td>\\n</tr>\\n<tr>\\n<td>5</td>\\n<td>F</td>\\n<td>2</td>\\n</tr>\\n<tr>\\n<td>6</td>\\n<td>H</td>\\n<td>3</td>\\n</tr>\\n<tr>\\n<td><strong>优点</strong>：找父亲、找根极快。</td>\\n<td></td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{h as comp,o as data};
